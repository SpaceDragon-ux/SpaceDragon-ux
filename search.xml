<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UCSC CTF 2025 WP</title>
      <link href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/"/>
      <url>/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/</url>
      
        <content type="html"><![CDATA[<h3 id="UCSC-CTF-2025-WP-—-PWN"><a href="#UCSC-CTF-2025-WP-—-PWN" class="headerlink" title="UCSC CTF 2025 WP —- PWN"></a>UCSC CTF 2025 WP —- PWN</h3><h4 id="BoFido"><a href="#BoFido" class="headerlink" title="BoFido"></a>BoFido</h4><p><img src="/WP%5CUCSC2025%5C1.png" alt="1"></p><p>常规检查： 64位程序 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/WP%5CUCSC2025%5C2.png" alt="2"></p><p>主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏</p><p>程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用 </p><p>要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件</p><p>而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对 </p><p>但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）<strong>所以这就需要我们来控制赌局的中奖率</strong> 从而达到把把全猜中的目的</p><p><strong><u>那么我们该如何利用漏洞进行实现呢？</u></strong></p><p><img src="/WP%5CUCSC2025%5C3.png" alt="image-20250422234155656"></p><p>我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：</p><hr><ul><li>C 语言提供了 <code>rand()</code> 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 <code>rand()</code> 函数时，它会根据内部的种子和算法生成下一个随机数。</li></ul><hr><p>但是如果程序每次都利用相同的种子，那么生成的随机数序列也会相同，这样就无法得到真正的随机数，所以通常我们都会以当前时间作为种子，因为时间是无时无刻发生变化的，这样生成的数值才会满足随机性。</p><p><strong>seed &#x3D; time(0LL)</strong></p><p>这行代码的作用是初始化时间的种子 这样我们得到的随机数就是完全随机的了</p><p>这样就不方便我们进行对赌局的把控 </p><p>转念一想，如果生成随机数是根据内部的种子和固定的算法决定的，这个种子因为程序进行了时间初始化，导致种子在不断变化，但如果我们在其生成时间的种子之后，对seed进行一个覆盖，把它覆盖为一个固定大小的值，<strong><u>这样我们生成的随机数序列就会变得有迹可循</u></strong></p><p><u>如果你能够预知未来，这样的赌局还会存在失误吗…..</u></p><p>由于程序给我们提供了一个0x25字节的输入点 恰好这个输入点存在一个漏洞 让我们进行一个利用</p><p><img src="/WP%5CUCSC2025%5C4.png" alt="image-20250422235747015"></p><p>可以看到输入点 buf 和随机数种子 seed 都存在于栈上，并且相距0x20字节（恰好在0x25输入范围以内）只要我们填充数据0x21个字节把seed覆盖成一个固定的值 这样随机数序列也会固定</p><p><img src="/WP%5CUCSC2025%5C5.png" alt="image-20250423000924364"></p><p>我选择直接填充0x21个的a字节，第一次运行程序记下十个回合的幸运数字，第二次运行程序直接按第一个回合的顺序打就可以直接打通</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter your name:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>待会 今天马上更完……</p>]]></content>
      
      
      <categories>
          
          <category> 比赛WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCSC CTF 2025 WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
